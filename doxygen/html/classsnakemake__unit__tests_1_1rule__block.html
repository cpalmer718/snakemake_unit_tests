<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snakemake_unit_tests: snakemake_unit_tests::rule_block Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">snakemake_unit_tests
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Replicate snakemake --generate-unit-tests functionality with the added benefit of actually working</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>snakemake_unit_tests</b></li><li class="navelem"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">snakemake_unit_tests::rule_block Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>command line argument parser using boost::program_options  
 <a href="classsnakemake__unit__tests_1_1rule__block.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rule__block_8h_source.html">rule_block.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a677876bfc5c03953f8b888368b1c068a"><td class="memItemLeft" align="right" valign="top"><a id="a677876bfc5c03953f8b888368b1c068a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a677876bfc5c03953f8b888368b1c068a">rule_block</a> ()</td></tr>
<tr class="memdesc:a677876bfc5c03953f8b888368b1c068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a677876bfc5c03953f8b888368b1c068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122be784b8ecf4651a76a653b0306ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a2122be784b8ecf4651a76a653b0306ea">rule_block</a> (const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;obj)</td></tr>
<tr class="memdesc:a2122be784b8ecf4651a76a653b0306ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classsnakemake__unit__tests_1_1rule__block.html#a2122be784b8ecf4651a76a653b0306ea">More...</a><br /></td></tr>
<tr class="separator:a2122be784b8ecf4651a76a653b0306ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="memItemLeft" align="right" valign="top"><a id="a0b7e1d766627db4e12d8c570fa6c3aba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a0b7e1d766627db4e12d8c570fa6c3aba">~rule_block</a> ()  throw ()</td></tr>
<tr class="memdesc:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadfda9cf06ee3429c4ab18f97c91a21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aeadfda9cf06ee3429c4ab18f97c91a21">load_content_block</a> (const std::vector&lt; std::string &gt; &amp;loaded_lines, const boost::filesystem::path &amp;filename, unsigned global_indentation, bool verbose, unsigned *current_line)</td></tr>
<tr class="memdesc:aeadfda9cf06ee3429c4ab18f97c91a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a rule block or python chunk from a snakemake file vector  <a href="classsnakemake__unit__tests_1_1rule__block.html#aeadfda9cf06ee3429c4ab18f97c91a21">More...</a><br /></td></tr>
<tr class="separator:aeadfda9cf06ee3429c4ab18f97c91a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4decffe2868da5c2b0ea7c233388240c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a4decffe2868da5c2b0ea7c233388240c">consume_rule_contents</a> (const std::vector&lt; std::string &gt; &amp;loaded_lines, const boost::filesystem::path &amp;filename, bool verbose, unsigned *current_line)</td></tr>
<tr class="memdesc:a4decffe2868da5c2b0ea7c233388240c"><td class="mdescLeft">&#160;</td><td class="mdescRight">having found a rule declaration, load its blocks  <a href="classsnakemake__unit__tests_1_1rule__block.html#a4decffe2868da5c2b0ea7c233388240c">More...</a><br /></td></tr>
<tr class="separator:a4decffe2868da5c2b0ea7c233388240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">set_rule_name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the rule  <a href="classsnakemake__unit__tests_1_1rule__block.html#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">More...</a><br /></td></tr>
<tr class="separator:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef19d37e8073831c34fb2590674b4de4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aef19d37e8073831c34fb2590674b4de4">get_rule_name</a> () const</td></tr>
<tr class="memdesc:aef19d37e8073831c34fb2590674b4de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the name of the rule  <a href="classsnakemake__unit__tests_1_1rule__block.html#aef19d37e8073831c34fb2590674b4de4">More...</a><br /></td></tr>
<tr class="separator:aef19d37e8073831c34fb2590674b4de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ab4f0b8b567ea6fd0573f986a16fb107d">set_base_rule_name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#ab4f0b8b567ea6fd0573f986a16fb107d">More...</a><br /></td></tr>
<tr class="separator:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a4c7bfd792416701392f04aa5ddcaa1bc">get_base_rule_name</a> () const</td></tr>
<tr class="memdesc:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the name of the base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a4c7bfd792416701392f04aa5ddcaa1bc">More...</a><br /></td></tr>
<tr class="separator:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad665a55afda39722a659d93010c76837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ad665a55afda39722a659d93010c76837">is_include_directive</a> () const</td></tr>
<tr class="memdesc:ad665a55afda39722a659d93010c76837"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether this block is a snakemake file include directive  <a href="classsnakemake__unit__tests_1_1rule__block.html#ad665a55afda39722a659d93010c76837">More...</a><br /></td></tr>
<tr class="separator:ad665a55afda39722a659d93010c76837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0e13d780edf9c03a2ddc203f372148"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#adc0e13d780edf9c03a2ddc203f372148">get_include_depth</a> () const</td></tr>
<tr class="memdesc:adc0e13d780edf9c03a2ddc203f372148"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine how much indentation an include directive enjoyed  <a href="classsnakemake__unit__tests_1_1rule__block.html#adc0e13d780edf9c03a2ddc203f372148">More...</a><br /></td></tr>
<tr class="separator:adc0e13d780edf9c03a2ddc203f372148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb00c8823aab86a6c7a983364007743"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a9eb00c8823aab86a6c7a983364007743">get_recursive_filename</a> () const</td></tr>
<tr class="memdesc:a9eb00c8823aab86a6c7a983364007743"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the block is an include directive, get the file that is included  <a href="classsnakemake__unit__tests_1_1rule__block.html#a9eb00c8823aab86a6c7a983364007743">More...</a><br /></td></tr>
<tr class="separator:a9eb00c8823aab86a6c7a983364007743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aa3429e0b3dde7eaeb99520dd629d6ba4">print_contents</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">report mildly formatted contents to a stream  <a href="classsnakemake__unit__tests_1_1rule__block.html#aa3429e0b3dde7eaeb99520dd629d6ba4">More...</a><br /></td></tr>
<tr class="separator:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa3e01a6b971a17402da027fca9273"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a3caa3e01a6b971a17402da027fca9273">get_code_chunk</a> () const</td></tr>
<tr class="memdesc:a3caa3e01a6b971a17402da027fca9273"><td class="mdescLeft">&#160;</td><td class="mdescRight">get internal storage of code chunk as const reference  <a href="classsnakemake__unit__tests_1_1rule__block.html#a3caa3e01a6b971a17402da027fca9273">More...</a><br /></td></tr>
<tr class="separator:a3caa3e01a6b971a17402da027fca9273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad0d8dab3d7390b316781fba25a187"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a27ad0d8dab3d7390b316781fba25a187">get_named_blocks</a> () const</td></tr>
<tr class="memdesc:a27ad0d8dab3d7390b316781fba25a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">get named blocks of rule body  <a href="classsnakemake__unit__tests_1_1rule__block.html#a27ad0d8dab3d7390b316781fba25a187">More...</a><br /></td></tr>
<tr class="separator:a27ad0d8dab3d7390b316781fba25a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73480255309a0a244c820346db9beb65"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a73480255309a0a244c820346db9beb65">get_global_indentation</a> () const</td></tr>
<tr class="memdesc:a73480255309a0a244c820346db9beb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">get global indentation of file  <a href="classsnakemake__unit__tests_1_1rule__block.html#a73480255309a0a244c820346db9beb65">More...</a><br /></td></tr>
<tr class="separator:a73480255309a0a244c820346db9beb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382259a591a1f4c9345523b23de4f478"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a382259a591a1f4c9345523b23de4f478">get_local_indentation</a> () const</td></tr>
<tr class="memdesc:a382259a591a1f4c9345523b23de4f478"><td class="mdescLeft">&#160;</td><td class="mdescRight">get local indentation of rule block  <a href="classsnakemake__unit__tests_1_1rule__block.html#a382259a591a1f4c9345523b23de4f478">More...</a><br /></td></tr>
<tr class="separator:a382259a591a1f4c9345523b23de4f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1be741a981cae72e5975a19d906f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a1fa1be741a981cae72e5975a19d906f9">offer_base_rule_contents</a> (const std::string &amp;provider_name, const std::string &amp;block_name, const std::string &amp;block_values)</td></tr>
<tr class="memdesc:a1fa1be741a981cae72e5975a19d906f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide candidate base rule block definitions for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a1fa1be741a981cae72e5975a19d906f9">More...</a><br /></td></tr>
<tr class="separator:a1fa1be741a981cae72e5975a19d906f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a1519c228e377353bb2f3a1e9e418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a087a1519c228e377353bb2f3a1e9e418">add_code_chunk</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a087a1519c228e377353bb2f3a1e9e418"><td class="mdescLeft">&#160;</td><td class="mdescRight">manually inject code into this block  <a href="classsnakemake__unit__tests_1_1rule__block.html#a087a1519c228e377353bb2f3a1e9e418">More...</a><br /></td></tr>
<tr class="separator:a087a1519c228e377353bb2f3a1e9e418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e3182649715cc41e4426d5f80f67f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a1e2e3182649715cc41e4426d5f80f67f">operator==</a> (const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;obj) const</td></tr>
<tr class="memdesc:a1e2e3182649715cc41e4426d5f80f67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">test equality  <a href="classsnakemake__unit__tests_1_1rule__block.html#a1e2e3182649715cc41e4426d5f80f67f">More...</a><br /></td></tr>
<tr class="separator:a1e2e3182649715cc41e4426d5f80f67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4472fc8a2403a5ce4503483940542cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ae4472fc8a2403a5ce4503483940542cb">operator!=</a> (const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;obj) const</td></tr>
<tr class="memdesc:ae4472fc8a2403a5ce4503483940542cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">test inequality  <a href="classsnakemake__unit__tests_1_1rule__block.html#ae4472fc8a2403a5ce4503483940542cb">More...</a><br /></td></tr>
<tr class="separator:ae4472fc8a2403a5ce4503483940542cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7b3bd3d8a1d72a864e5eaabe2ac41daf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a7b3bd3d8a1d72a864e5eaabe2ac41daf">reduce_relative_paths</a> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a7b3bd3d8a1d72a864e5eaabe2ac41daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply hackjob nonsense to flatten certain relative paths by one level  <a href="classsnakemake__unit__tests_1_1rule__block.html#a7b3bd3d8a1d72a864e5eaabe2ac41daf">More...</a><br /></td></tr>
<tr class="separator:a7b3bd3d8a1d72a864e5eaabe2ac41daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b706d3d1999c8937faab48c28038545"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a1b706d3d1999c8937faab48c28038545">indentation</a> (unsigned count) const</td></tr>
<tr class="memdesc:a1b706d3d1999c8937faab48c28038545"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a string containing some number of whitespaces  <a href="classsnakemake__unit__tests_1_1rule__block.html#a1b706d3d1999c8937faab48c28038545">More...</a><br /></td></tr>
<tr class="separator:a1b706d3d1999c8937faab48c28038545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90782db2c2213aa8133e6daa478c6c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ab90782db2c2213aa8133e6daa478c6c0">apply_indentation</a> (const std::string &amp;s, unsigned count) const</td></tr>
<tr class="memdesc:ab90782db2c2213aa8133e6daa478c6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace embedded newlines in a string with newlines plus indentation  <a href="classsnakemake__unit__tests_1_1rule__block.html#ab90782db2c2213aa8133e6daa478c6c0">More...</a><br /></td></tr>
<tr class="separator:ab90782db2c2213aa8133e6daa478c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="memItemLeft" align="right" valign="top"><a id="aa24047e29c6cdf6bbb50c7ed6d2f527a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aa24047e29c6cdf6bbb50c7ed6d2f527a">clear</a> ()</td></tr>
<tr class="memdesc:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear out internal storage <br /></td></tr>
<tr class="separator:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2c3d50d1780b52a0189047637fed8dd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a2c3d50d1780b52a0189047637fed8dd0">_rule_name</a></td></tr>
<tr class="memdesc:a2c3d50d1780b52a0189047637fed8dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">declared rule name  <a href="classsnakemake__unit__tests_1_1rule__block.html#a2c3d50d1780b52a0189047637fed8dd0">More...</a><br /></td></tr>
<tr class="separator:a2c3d50d1780b52a0189047637fed8dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a22523a1aa4fa7a7675ee64129b1e1ce2">_base_rule_name</a></td></tr>
<tr class="memdesc:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">name of base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a22523a1aa4fa7a7675ee64129b1e1ce2">More...</a><br /></td></tr>
<tr class="separator:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2c13d1921d6c5c31d507f346850767"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aea2c13d1921d6c5c31d507f346850767">_named_blocks</a></td></tr>
<tr class="memdesc:aea2c13d1921d6c5c31d507f346850767"><td class="mdescLeft">&#160;</td><td class="mdescRight">arbitrary named blocks and their contents  <a href="classsnakemake__unit__tests_1_1rule__block.html#aea2c13d1921d6c5c31d507f346850767">More...</a><br /></td></tr>
<tr class="separator:aea2c13d1921d6c5c31d507f346850767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4a75de30ebdd1d00f76990337943e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a51a4a75de30ebdd1d00f76990337943e">_code_chunk</a></td></tr>
<tr class="memdesc:a51a4a75de30ebdd1d00f76990337943e"><td class="mdescLeft">&#160;</td><td class="mdescRight">arbitrary python code chunk that can exist between rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a51a4a75de30ebdd1d00f76990337943e">More...</a><br /></td></tr>
<tr class="separator:a51a4a75de30ebdd1d00f76990337943e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c0874e6f1392e63c6a7c46631adcac"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a28c0874e6f1392e63c6a7c46631adcac">_global_indentation</a></td></tr>
<tr class="memdesc:a28c0874e6f1392e63c6a7c46631adcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">allow for global indentation of conditionally included files  <a href="classsnakemake__unit__tests_1_1rule__block.html#a28c0874e6f1392e63c6a7c46631adcac">More...</a><br /></td></tr>
<tr class="separator:a28c0874e6f1392e63c6a7c46631adcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695111cc2a3a27df46bb5580625f82cd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a695111cc2a3a27df46bb5580625f82cd">_local_indentation</a></td></tr>
<tr class="memdesc:a695111cc2a3a27df46bb5580625f82cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">allow for local indentation of conditionally included rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a695111cc2a3a27df46bb5580625f82cd">More...</a><br /></td></tr>
<tr class="separator:a695111cc2a3a27df46bb5580625f82cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>command line argument parser using boost::program_options </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2122be784b8ecf4651a76a653b0306ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2122be784b8ecf4651a76a653b0306ea">&#9670;&nbsp;</a></span>rule_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">snakemake_unit_tests::rule_block::rule_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>existing rule block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a087a1519c228e377353bb2f3a1e9e418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087a1519c228e377353bb2f3a1e9e418">&#9670;&nbsp;</a></span>add_code_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::add_code_chunk </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>manually inject code into this block </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>code to inject</td></tr>
  </table>
  </dd>
</dl>
<p>required for the redesign of the parser </p>

</div>
</div>
<a id="ab90782db2c2213aa8133e6daa478c6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90782db2c2213aa8133e6daa478c6c0">&#9670;&nbsp;</a></span>apply_indentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::apply_indentation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replace embedded newlines in a string with newlines plus indentation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>input string, possibly with embedded newlines </td></tr>
    <tr><td class="paramname">count</td><td>total whitespace indentation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reformatted input string</dd></dl>
<p>this is intended for use with rule block contents, and as such does not interact with the implied newline at the end of the string </p>

</div>
</div>
<a id="a4decffe2868da5c2b0ea7c233388240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4decffe2868da5c2b0ea7c233388240c">&#9670;&nbsp;</a></span>consume_rule_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::consume_rule_contents </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>loaded_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>current_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>having found a rule declaration, load its blocks </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loaded_lines</td><td>vector of snakemake lines to process </td></tr>
    <tr><td class="paramname">filename</td><td>name of the loaded snakemake file. only used for informative error messages </td></tr>
    <tr><td class="paramname">verbose</td><td>whether to report verbose logging output </td></tr>
    <tr><td class="paramname">current_line</td><td>currently probed line tracker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether a rule was successfully loaded </dd></dl>

</div>
</div>
<a id="a4c7bfd792416701392f04aa5ddcaa1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7bfd792416701392f04aa5ddcaa1bc">&#9670;&nbsp;</a></span>get_base_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; snakemake_unit_tests::rule_block::get_base_rule_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the name of the base rule for derived rules </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the base rule if applicable, or an empty string </dd></dl>

</div>
</div>
<a id="a3caa3e01a6b971a17402da027fca9273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caa3e01a6b971a17402da027fca9273">&#9670;&nbsp;</a></span>get_code_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; snakemake_unit_tests::rule_block::get_code_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get internal storage of code chunk as const reference </p>
<dl class="section return"><dt>Returns</dt><dd>code chunk as const reference </dd></dl>

</div>
</div>
<a id="a73480255309a0a244c820346db9beb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73480255309a0a244c820346db9beb65">&#9670;&nbsp;</a></span>get_global_indentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::get_global_indentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get global indentation of file </p>
<dl class="section return"><dt>Returns</dt><dd>global indentation of file </dd></dl>

</div>
</div>
<a id="adc0e13d780edf9c03a2ddc203f372148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0e13d780edf9c03a2ddc203f372148">&#9670;&nbsp;</a></span>get_include_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::get_include_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine how much indentation an include directive enjoyed </p>
<dl class="section return"><dt>Returns</dt><dd>indentation of include directive, along with inherited global depth </dd></dl>

</div>
</div>
<a id="a382259a591a1f4c9345523b23de4f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382259a591a1f4c9345523b23de4f478">&#9670;&nbsp;</a></span>get_local_indentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::get_local_indentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get local indentation of rule block </p>
<dl class="section return"><dt>Returns</dt><dd>local indentation of rule block </dd></dl>

</div>
</div>
<a id="a27ad0d8dab3d7390b316781fba25a187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad0d8dab3d7390b316781fba25a187">&#9670;&nbsp;</a></span>get_named_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, std::string&gt;&amp; snakemake_unit_tests::rule_block::get_named_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get named blocks of rule body </p>
<dl class="section return"><dt>Returns</dt><dd>named blocks of rule body, or empty map </dd></dl>

</div>
</div>
<a id="a9eb00c8823aab86a6c7a983364007743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb00c8823aab86a6c7a983364007743">&#9670;&nbsp;</a></span>get_recursive_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::get_recursive_filename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the block is an include directive, get the file that is included </p>
<dl class="section return"><dt>Returns</dt><dd>the included filename </dd></dl>

</div>
</div>
<a id="aef19d37e8073831c34fb2590674b4de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef19d37e8073831c34fb2590674b4de4">&#9670;&nbsp;</a></span>get_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; snakemake_unit_tests::rule_block::get_rule_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the name of the rule </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the rule</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>regex matching is currently borked, this entry may be garbage </dd></dl>

</div>
</div>
<a id="a1b706d3d1999c8937faab48c28038545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b706d3d1999c8937faab48c28038545">&#9670;&nbsp;</a></span>indentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::indentation </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a string containing some number of whitespaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>total whitespace indentation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>formatted indentation whitespace </dd></dl>

</div>
</div>
<a id="ad665a55afda39722a659d93010c76837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad665a55afda39722a659d93010c76837">&#9670;&nbsp;</a></span>is_include_directive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::is_include_directive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine whether this block is a snakemake file include directive </p>
<dl class="section return"><dt>Returns</dt><dd>whether the block is an include directive, hopefully </dd></dl>

</div>
</div>
<a id="aeadfda9cf06ee3429c4ab18f97c91a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadfda9cf06ee3429c4ab18f97c91a21">&#9670;&nbsp;</a></span>load_content_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::load_content_block </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>loaded_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>global_indentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>current_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a rule block or python chunk from a snakemake file vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loaded_lines</td><td>vector of snakemake file lines to process </td></tr>
    <tr><td class="paramname">filename</td><td>name of the loaded snakemake file. only used for informative error messages </td></tr>
    <tr><td class="paramname">global_indentation</td><td>base indentation for entire file, defaulting to 0 for standard file loads and incrementing by 4 for each level of indentation the include directive had within its python block </td></tr>
    <tr><td class="paramname">verbose</td><td>whether to report verbose logging output </td></tr>
    <tr><td class="paramname">current_line</td><td>currently probed line tracker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether a rule was successfully loaded</dd></dl>
<p>this function will parse out a single rule from a snakemake file. it is designed to be called until it returns false. </p>

</div>
</div>
<a id="a1fa1be741a981cae72e5975a19d906f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa1be741a981cae72e5975a19d906f9">&#9670;&nbsp;</a></span>offer_base_rule_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::offer_base_rule_contents </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>provider_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>block_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>block_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide candidate base rule block definitions for derived rules </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider_name</td><td>name of candidate base rule providing this information </td></tr>
    <tr><td class="paramname">block_name</td><td>name of block definition from the base rule </td></tr>
    <tr><td class="paramname">block_values</td><td>contents of block from the base rule</td></tr>
  </table>
  </dd>
</dl>
<p>for safety, the rule will check that such a suggestion is sane, and respond accordingly if not </p>

</div>
</div>
<a id="ae4472fc8a2403a5ce4503483940542cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4472fc8a2403a5ce4503483940542cb">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test inequality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>other <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html" title="command line argument parser using boost::program_options">rule_block</a> object to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether *this and obj contain the same contents</dd></dl>
<p>note that indentation level is irrelevant for this comparison </p>

</div>
</div>
<a id="a1e2e3182649715cc41e4426d5f80f67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e3182649715cc41e4426d5f80f67f">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test equality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>other <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html" title="command line argument parser using boost::program_options">rule_block</a> object to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether *this and obj contain the same contents</dd></dl>
<p>note that indentation level is irrelevant for this comparison </p>

</div>
</div>
<a id="aa3429e0b3dde7eaeb99520dd629d6ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3429e0b3dde7eaeb99520dd629d6ba4">&#9670;&nbsp;</a></span>print_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::print_contents </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>report mildly formatted contents to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>an open stream to which to write formatted contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b3bd3d8a1d72a864e5eaabe2ac41daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3bd3d8a1d72a864e5eaabe2ac41daf">&#9670;&nbsp;</a></span>reduce_relative_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::reduce_relative_paths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply hackjob nonsense to flatten certain relative paths by one level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>possible relative path to flatten </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input line with any changes applied</dd></dl>
<p>this is flagged to be handled some other way TODO(cpalmer718): find any better way of flattening relative include paths </p>

</div>
</div>
<a id="ab4f0b8b567ea6fd0573f986a16fb107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f0b8b567ea6fd0573f986a16fb107d">&#9670;&nbsp;</a></span>set_base_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_base_rule_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the name of the base rule for derived rules </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new name of base rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e39b5aaea4f9b7a7e96cc3d0a5dba50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">&#9670;&nbsp;</a></span>set_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_rule_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the name of the rule </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new name of rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a22523a1aa4fa7a7675ee64129b1e1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22523a1aa4fa7a7675ee64129b1e1ce2">&#9670;&nbsp;</a></span>_base_rule_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::_base_rule_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>name of base rule for derived rules </p>
<p>only a snakemake 6.0+ feature. for these rules, some entries will be populated later </p>

</div>
</div>
<a id="a51a4a75de30ebdd1d00f76990337943e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a4a75de30ebdd1d00f76990337943e">&#9670;&nbsp;</a></span>_code_chunk</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; snakemake_unit_tests::rule_block::_code_chunk</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>arbitrary python code chunk that can exist between rules </p>
<p>this wasn't the original intention of this class, but rather than deal with derived classes and other nonsense, since arbitrary code blocks follow the same logic as rule blocks, they can just be stored in their own copy of this class </p>

</div>
</div>
<a id="a28c0874e6f1392e63c6a7c46631adcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c0874e6f1392e63c6a7c46631adcac">&#9670;&nbsp;</a></span>_global_indentation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::_global_indentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allow for global indentation of conditionally included files </p>
<p>files included within python blocks should inherit the base depth of their include directive. </p>

</div>
</div>
<a id="a695111cc2a3a27df46bb5580625f82cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695111cc2a3a27df46bb5580625f82cd">&#9670;&nbsp;</a></span>_local_indentation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::_local_indentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allow for local indentation of conditionally included rules </p>
<p>rules included within python blocks should temporarily have escalated indentation, which determines the end of the rule block later in the file </p>

</div>
</div>
<a id="aea2c13d1921d6c5c31d507f346850767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2c13d1921d6c5c31d507f346850767">&#9670;&nbsp;</a></span>_named_blocks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; snakemake_unit_tests::rule_block::_named_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>arbitrary named blocks and their contents </p>
<p>input and output blocks need to be handled specially, but the others can be arbitrarily specified. </p>

</div>
</div>
<a id="a2c3d50d1780b52a0189047637fed8dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3d50d1780b52a0189047637fed8dd0">&#9670;&nbsp;</a></span>_rule_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::_rule_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>declared rule name </p>
<p>needs to be unique, but should be if the snakemake run was successful </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>snakemake_unit_tests/<a class="el" href="rule__block_8h_source.html">rule_block.h</a></li>
<li>snakemake_unit_tests/<a class="el" href="rule__block_8cc.html">rule_block.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
