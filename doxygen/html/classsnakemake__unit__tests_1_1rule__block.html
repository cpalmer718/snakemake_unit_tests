<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snakemake_unit_tests: snakemake_unit_tests::rule_block Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">snakemake_unit_tests
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Replicate snakemake --generate-unit-tests functionality with the added benefit of actually working</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>snakemake_unit_tests</b></li><li class="navelem"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">snakemake_unit_tests::rule_block Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>command line argument parser using boost::program_options  
 <a href="classsnakemake__unit__tests_1_1rule__block.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rule__block_8h_source.html">rule_block.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a677876bfc5c03953f8b888368b1c068a"><td class="memItemLeft" align="right" valign="top"><a id="a677876bfc5c03953f8b888368b1c068a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a677876bfc5c03953f8b888368b1c068a">rule_block</a> ()</td></tr>
<tr class="memdesc:a677876bfc5c03953f8b888368b1c068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a677876bfc5c03953f8b888368b1c068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122be784b8ecf4651a76a653b0306ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a2122be784b8ecf4651a76a653b0306ea">rule_block</a> (const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;obj)</td></tr>
<tr class="memdesc:a2122be784b8ecf4651a76a653b0306ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classsnakemake__unit__tests_1_1rule__block.html#a2122be784b8ecf4651a76a653b0306ea">More...</a><br /></td></tr>
<tr class="separator:a2122be784b8ecf4651a76a653b0306ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="memItemLeft" align="right" valign="top"><a id="a0b7e1d766627db4e12d8c570fa6c3aba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a0b7e1d766627db4e12d8c570fa6c3aba">~rule_block</a> ()  throw ()</td></tr>
<tr class="memdesc:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf927b20041709feada18491666b5cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a8bf927b20041709feada18491666b5cb">load_snakemake_rule</a> (std::ifstream &amp;input, const std::string &amp;filename, bool verbose)</td></tr>
<tr class="memdesc:a8bf927b20041709feada18491666b5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a rule block from a snakemake file stream  <a href="classsnakemake__unit__tests_1_1rule__block.html#a8bf927b20041709feada18491666b5cb">More...</a><br /></td></tr>
<tr class="separator:a8bf927b20041709feada18491666b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">set_rule_name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the rule  <a href="classsnakemake__unit__tests_1_1rule__block.html#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">More...</a><br /></td></tr>
<tr class="separator:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef19d37e8073831c34fb2590674b4de4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aef19d37e8073831c34fb2590674b4de4">get_rule_name</a> () const</td></tr>
<tr class="memdesc:aef19d37e8073831c34fb2590674b4de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the name of the rule  <a href="classsnakemake__unit__tests_1_1rule__block.html#aef19d37e8073831c34fb2590674b4de4">More...</a><br /></td></tr>
<tr class="separator:aef19d37e8073831c34fb2590674b4de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ab4f0b8b567ea6fd0573f986a16fb107d">set_base_rule_name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#ab4f0b8b567ea6fd0573f986a16fb107d">More...</a><br /></td></tr>
<tr class="separator:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a4c7bfd792416701392f04aa5ddcaa1bc">get_base_rule_name</a> () const</td></tr>
<tr class="memdesc:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the name of the base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a4c7bfd792416701392f04aa5ddcaa1bc">More...</a><br /></td></tr>
<tr class="separator:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad665a55afda39722a659d93010c76837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ad665a55afda39722a659d93010c76837">is_include_directive</a> () const</td></tr>
<tr class="memdesc:ad665a55afda39722a659d93010c76837"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether this block is a snakemake file include directive  <a href="classsnakemake__unit__tests_1_1rule__block.html#ad665a55afda39722a659d93010c76837">More...</a><br /></td></tr>
<tr class="separator:ad665a55afda39722a659d93010c76837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb00c8823aab86a6c7a983364007743"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a9eb00c8823aab86a6c7a983364007743">get_recursive_filename</a> () const</td></tr>
<tr class="memdesc:a9eb00c8823aab86a6c7a983364007743"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the block is an include directive, get the file that is included  <a href="classsnakemake__unit__tests_1_1rule__block.html#a9eb00c8823aab86a6c7a983364007743">More...</a><br /></td></tr>
<tr class="separator:a9eb00c8823aab86a6c7a983364007743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aa3429e0b3dde7eaeb99520dd629d6ba4">print_contents</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">report mildly formatted contents to a stream  <a href="classsnakemake__unit__tests_1_1rule__block.html#aa3429e0b3dde7eaeb99520dd629d6ba4">More...</a><br /></td></tr>
<tr class="separator:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa3e01a6b971a17402da027fca9273"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a3caa3e01a6b971a17402da027fca9273">get_code_chunk</a> () const</td></tr>
<tr class="memdesc:a3caa3e01a6b971a17402da027fca9273"><td class="mdescLeft">&#160;</td><td class="mdescRight">get internal storage of code chunk as const reference  <a href="classsnakemake__unit__tests_1_1rule__block.html#a3caa3e01a6b971a17402da027fca9273">More...</a><br /></td></tr>
<tr class="separator:a3caa3e01a6b971a17402da027fca9273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad0d8dab3d7390b316781fba25a187"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a27ad0d8dab3d7390b316781fba25a187">get_named_blocks</a> () const</td></tr>
<tr class="memdesc:a27ad0d8dab3d7390b316781fba25a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">get named blocks of rule body  <a href="classsnakemake__unit__tests_1_1rule__block.html#a27ad0d8dab3d7390b316781fba25a187">More...</a><br /></td></tr>
<tr class="separator:a27ad0d8dab3d7390b316781fba25a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1be741a981cae72e5975a19d906f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a1fa1be741a981cae72e5975a19d906f9">offer_base_rule_contents</a> (const std::string &amp;provider_name, const std::string &amp;block_name, const std::string &amp;block_values)</td></tr>
<tr class="memdesc:a1fa1be741a981cae72e5975a19d906f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide candidate base rule block definitions for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a1fa1be741a981cae72e5975a19d906f9">More...</a><br /></td></tr>
<tr class="separator:a1fa1be741a981cae72e5975a19d906f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="memItemLeft" align="right" valign="top"><a id="aa24047e29c6cdf6bbb50c7ed6d2f527a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aa24047e29c6cdf6bbb50c7ed6d2f527a">clear</a> ()</td></tr>
<tr class="memdesc:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear out internal storage <br /></td></tr>
<tr class="separator:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2c3d50d1780b52a0189047637fed8dd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a2c3d50d1780b52a0189047637fed8dd0">_rule_name</a></td></tr>
<tr class="memdesc:a2c3d50d1780b52a0189047637fed8dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">declared rule name  <a href="classsnakemake__unit__tests_1_1rule__block.html#a2c3d50d1780b52a0189047637fed8dd0">More...</a><br /></td></tr>
<tr class="separator:a2c3d50d1780b52a0189047637fed8dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a22523a1aa4fa7a7675ee64129b1e1ce2">_base_rule_name</a></td></tr>
<tr class="memdesc:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">name of base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a22523a1aa4fa7a7675ee64129b1e1ce2">More...</a><br /></td></tr>
<tr class="separator:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2c13d1921d6c5c31d507f346850767"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aea2c13d1921d6c5c31d507f346850767">_named_blocks</a></td></tr>
<tr class="memdesc:aea2c13d1921d6c5c31d507f346850767"><td class="mdescLeft">&#160;</td><td class="mdescRight">arbitrary named blocks and their contents  <a href="classsnakemake__unit__tests_1_1rule__block.html#aea2c13d1921d6c5c31d507f346850767">More...</a><br /></td></tr>
<tr class="separator:aea2c13d1921d6c5c31d507f346850767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4a75de30ebdd1d00f76990337943e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a51a4a75de30ebdd1d00f76990337943e">_code_chunk</a></td></tr>
<tr class="memdesc:a51a4a75de30ebdd1d00f76990337943e"><td class="mdescLeft">&#160;</td><td class="mdescRight">arbitrary python code chunk that can exist between rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a51a4a75de30ebdd1d00f76990337943e">More...</a><br /></td></tr>
<tr class="separator:a51a4a75de30ebdd1d00f76990337943e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>command line argument parser using boost::program_options </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2122be784b8ecf4651a76a653b0306ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2122be784b8ecf4651a76a653b0306ea">&#9670;&nbsp;</a></span>rule_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">snakemake_unit_tests::rule_block::rule_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>existing rule block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c7bfd792416701392f04aa5ddcaa1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7bfd792416701392f04aa5ddcaa1bc">&#9670;&nbsp;</a></span>get_base_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; snakemake_unit_tests::rule_block::get_base_rule_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the name of the base rule for derived rules </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the base rule if applicable, or an empty string </dd></dl>

</div>
</div>
<a id="a3caa3e01a6b971a17402da027fca9273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caa3e01a6b971a17402da027fca9273">&#9670;&nbsp;</a></span>get_code_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; snakemake_unit_tests::rule_block::get_code_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get internal storage of code chunk as const reference </p>
<dl class="section return"><dt>Returns</dt><dd>code chunk as const reference </dd></dl>

</div>
</div>
<a id="a27ad0d8dab3d7390b316781fba25a187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad0d8dab3d7390b316781fba25a187">&#9670;&nbsp;</a></span>get_named_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, std::string&gt;&amp; snakemake_unit_tests::rule_block::get_named_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get named blocks of rule body </p>
<dl class="section return"><dt>Returns</dt><dd>named blocks of rule body, or empty map </dd></dl>

</div>
</div>
<a id="a9eb00c8823aab86a6c7a983364007743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb00c8823aab86a6c7a983364007743">&#9670;&nbsp;</a></span>get_recursive_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::get_recursive_filename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the block is an include directive, get the file that is included </p>
<dl class="section return"><dt>Returns</dt><dd>the included filename </dd></dl>

</div>
</div>
<a id="aef19d37e8073831c34fb2590674b4de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef19d37e8073831c34fb2590674b4de4">&#9670;&nbsp;</a></span>get_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; snakemake_unit_tests::rule_block::get_rule_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the name of the rule </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the rule</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>regex matching is currently borked, this entry may be garbage </dd></dl>

</div>
</div>
<a id="ad665a55afda39722a659d93010c76837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad665a55afda39722a659d93010c76837">&#9670;&nbsp;</a></span>is_include_directive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::is_include_directive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine whether this block is a snakemake file include directive </p>
<dl class="section return"><dt>Returns</dt><dd>whether the block is an include directive, hopefully </dd></dl>

</div>
</div>
<a id="a8bf927b20041709feada18491666b5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf927b20041709feada18491666b5cb">&#9670;&nbsp;</a></span>load_snakemake_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::load_snakemake_rule </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a rule block from a snakemake file stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an open file stream connected to a snakemake file </td></tr>
    <tr><td class="paramname">filename</td><td>name of the open snakemake file. only used for informative error messages </td></tr>
    <tr><td class="paramname">verbose</td><td>whether to report verbose logging output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether a rule was successfully loaded</dd></dl>
<p>this function will parse out a single rule from a snakemake file. it is designed to be called until it returns false. </p>

</div>
</div>
<a id="a1fa1be741a981cae72e5975a19d906f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa1be741a981cae72e5975a19d906f9">&#9670;&nbsp;</a></span>offer_base_rule_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::offer_base_rule_contents </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>provider_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>block_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>block_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide candidate base rule block definitions for derived rules </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider_name</td><td>name of candidate base rule providing this information </td></tr>
    <tr><td class="paramname">block_name</td><td>name of block definition from the base rule </td></tr>
    <tr><td class="paramname">block_values</td><td>contents of block from the base rule</td></tr>
  </table>
  </dd>
</dl>
<p>for safety, the rule will check that such a suggestion is sane, and respond accordingly if not </p>

</div>
</div>
<a id="aa3429e0b3dde7eaeb99520dd629d6ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3429e0b3dde7eaeb99520dd629d6ba4">&#9670;&nbsp;</a></span>print_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::print_contents </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>report mildly formatted contents to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>an open stream to which to write formatted contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4f0b8b567ea6fd0573f986a16fb107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f0b8b567ea6fd0573f986a16fb107d">&#9670;&nbsp;</a></span>set_base_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_base_rule_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the name of the base rule for derived rules </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new name of base rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e39b5aaea4f9b7a7e96cc3d0a5dba50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">&#9670;&nbsp;</a></span>set_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_rule_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the name of the rule </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new name of rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a22523a1aa4fa7a7675ee64129b1e1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22523a1aa4fa7a7675ee64129b1e1ce2">&#9670;&nbsp;</a></span>_base_rule_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::_base_rule_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>name of base rule for derived rules </p>
<p>only a snakemake 6.0+ feature. for these rules, some entries will be populated later </p>

</div>
</div>
<a id="a51a4a75de30ebdd1d00f76990337943e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a4a75de30ebdd1d00f76990337943e">&#9670;&nbsp;</a></span>_code_chunk</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; snakemake_unit_tests::rule_block::_code_chunk</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>arbitrary python code chunk that can exist between rules </p>
<p>this wasn't the original intention of this class, but rather than deal with derived classes and other nonsense, since arbitrary code blocks follow the same logic as rule blocks, they can just be stored in their own copy of this class </p>

</div>
</div>
<a id="aea2c13d1921d6c5c31d507f346850767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2c13d1921d6c5c31d507f346850767">&#9670;&nbsp;</a></span>_named_blocks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; snakemake_unit_tests::rule_block::_named_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>arbitrary named blocks and their contents </p>
<p>input and output blocks need to be handled specially, but the others can be arbitrarily specified. </p>

</div>
</div>
<a id="a2c3d50d1780b52a0189047637fed8dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3d50d1780b52a0189047637fed8dd0">&#9670;&nbsp;</a></span>_rule_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::_rule_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>declared rule name </p>
<p>needs to be unique, but should be if the snakemake run was successful </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>snakemake_unit_tests/<a class="el" href="rule__block_8h_source.html">rule_block.h</a></li>
<li>snakemake_unit_tests/<a class="el" href="rule__block_8cc.html">rule_block.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
