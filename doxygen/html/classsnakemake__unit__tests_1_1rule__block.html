<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snakemake_unit_tests: snakemake_unit_tests::rule_block Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">snakemake_unit_tests
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Replicate snakemake --generate-unit-tests functionality with the added benefit of actually working</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>snakemake_unit_tests</b></li><li class="navelem"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">snakemake_unit_tests::rule_block Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>command line argument parser using boost::program_options  
 <a href="classsnakemake__unit__tests_1_1rule__block.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rule__block_8h_source.html">rule_block.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a677876bfc5c03953f8b888368b1c068a"><td class="memItemLeft" align="right" valign="top"><a id="a677876bfc5c03953f8b888368b1c068a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a677876bfc5c03953f8b888368b1c068a">rule_block</a> ()</td></tr>
<tr class="memdesc:a677876bfc5c03953f8b888368b1c068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a677876bfc5c03953f8b888368b1c068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122be784b8ecf4651a76a653b0306ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a2122be784b8ecf4651a76a653b0306ea">rule_block</a> (const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;obj)</td></tr>
<tr class="memdesc:a2122be784b8ecf4651a76a653b0306ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classsnakemake__unit__tests_1_1rule__block.html#a2122be784b8ecf4651a76a653b0306ea">More...</a><br /></td></tr>
<tr class="separator:a2122be784b8ecf4651a76a653b0306ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="memItemLeft" align="right" valign="top"><a id="a0b7e1d766627db4e12d8c570fa6c3aba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a0b7e1d766627db4e12d8c570fa6c3aba">~rule_block</a> ()  throw ()</td></tr>
<tr class="memdesc:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a0b7e1d766627db4e12d8c570fa6c3aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96a6ee8aa9d2afad7a050cc2d7a1a01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ad96a6ee8aa9d2afad7a050cc2d7a1a01">load_content_block</a> (const std::vector&lt; std::string &gt; &amp;loaded_lines, const boost::filesystem::path &amp;filename, bool verbose, unsigned *current_line)</td></tr>
<tr class="memdesc:ad96a6ee8aa9d2afad7a050cc2d7a1a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a rule block or python chunk from a snakemake file vector  <a href="classsnakemake__unit__tests_1_1rule__block.html#ad96a6ee8aa9d2afad7a050cc2d7a1a01">More...</a><br /></td></tr>
<tr class="separator:ad96a6ee8aa9d2afad7a050cc2d7a1a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e3501a0700e32515aef16647f71753"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a12e3501a0700e32515aef16647f71753">consume_rule_contents</a> (const std::vector&lt; std::string &gt; &amp;loaded_lines, const boost::filesystem::path &amp;filename, bool verbose, unsigned *current_line, unsigned block_base_increment)</td></tr>
<tr class="memdesc:a12e3501a0700e32515aef16647f71753"><td class="mdescLeft">&#160;</td><td class="mdescRight">having found a rule declaration, load its blocks  <a href="classsnakemake__unit__tests_1_1rule__block.html#a12e3501a0700e32515aef16647f71753">More...</a><br /></td></tr>
<tr class="separator:a12e3501a0700e32515aef16647f71753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">set_rule_name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the rule  <a href="classsnakemake__unit__tests_1_1rule__block.html#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">More...</a><br /></td></tr>
<tr class="separator:a9e39b5aaea4f9b7a7e96cc3d0a5dba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef19d37e8073831c34fb2590674b4de4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aef19d37e8073831c34fb2590674b4de4">get_rule_name</a> () const</td></tr>
<tr class="memdesc:aef19d37e8073831c34fb2590674b4de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the name of the rule  <a href="classsnakemake__unit__tests_1_1rule__block.html#aef19d37e8073831c34fb2590674b4de4">More...</a><br /></td></tr>
<tr class="separator:aef19d37e8073831c34fb2590674b4de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ab4f0b8b567ea6fd0573f986a16fb107d">set_base_rule_name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#ab4f0b8b567ea6fd0573f986a16fb107d">More...</a><br /></td></tr>
<tr class="separator:ab4f0b8b567ea6fd0573f986a16fb107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a4c7bfd792416701392f04aa5ddcaa1bc">get_base_rule_name</a> () const</td></tr>
<tr class="memdesc:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the name of the base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a4c7bfd792416701392f04aa5ddcaa1bc">More...</a><br /></td></tr>
<tr class="separator:a4c7bfd792416701392f04aa5ddcaa1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151f7493f2ecc40227a52812c76f7c5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a151f7493f2ecc40227a52812c76f7c5f">is_simple_include_directive</a> () const</td></tr>
<tr class="memdesc:a151f7493f2ecc40227a52812c76f7c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether this block is a simple snakemake include directive  <a href="classsnakemake__unit__tests_1_1rule__block.html#a151f7493f2ecc40227a52812c76f7c5f">More...</a><br /></td></tr>
<tr class="separator:a151f7493f2ecc40227a52812c76f7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65f435719bfb7e63869c881b589ded1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ab65f435719bfb7e63869c881b589ded1">contains_include_directive</a> () const</td></tr>
<tr class="memdesc:ab65f435719bfb7e63869c881b589ded1"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether this block contains something that looks like an include directive but that doesn't conform to basic include syntax  <a href="classsnakemake__unit__tests_1_1rule__block.html#ab65f435719bfb7e63869c881b589ded1">More...</a><br /></td></tr>
<tr class="separator:ab65f435719bfb7e63869c881b589ded1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae696927452c2be2a023910739ec846a7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ae696927452c2be2a023910739ec846a7">get_filename_expression</a> () const</td></tr>
<tr class="memdesc:ae696927452c2be2a023910739ec846a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the filename expression from an include statement  <a href="classsnakemake__unit__tests_1_1rule__block.html#ae696927452c2be2a023910739ec846a7">More...</a><br /></td></tr>
<tr class="separator:ae696927452c2be2a023910739ec846a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0e13d780edf9c03a2ddc203f372148"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#adc0e13d780edf9c03a2ddc203f372148">get_include_depth</a> () const</td></tr>
<tr class="memdesc:adc0e13d780edf9c03a2ddc203f372148"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine how much indentation an include directive enjoyed  <a href="classsnakemake__unit__tests_1_1rule__block.html#adc0e13d780edf9c03a2ddc203f372148">More...</a><br /></td></tr>
<tr class="separator:adc0e13d780edf9c03a2ddc203f372148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501517c9b7fd13e0e4d716850a5cd04e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a501517c9b7fd13e0e4d716850a5cd04e">get_standard_filename</a> () const</td></tr>
<tr class="memdesc:a501517c9b7fd13e0e4d716850a5cd04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the block is an include directive, get the file that is included  <a href="classsnakemake__unit__tests_1_1rule__block.html#a501517c9b7fd13e0e4d716850a5cd04e">More...</a><br /></td></tr>
<tr class="separator:a501517c9b7fd13e0e4d716850a5cd04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aa3429e0b3dde7eaeb99520dd629d6ba4">print_contents</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">report mildly formatted contents to a stream  <a href="classsnakemake__unit__tests_1_1rule__block.html#aa3429e0b3dde7eaeb99520dd629d6ba4">More...</a><br /></td></tr>
<tr class="separator:aa3429e0b3dde7eaeb99520dd629d6ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa3e01a6b971a17402da027fca9273"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a3caa3e01a6b971a17402da027fca9273">get_code_chunk</a> () const</td></tr>
<tr class="memdesc:a3caa3e01a6b971a17402da027fca9273"><td class="mdescLeft">&#160;</td><td class="mdescRight">get internal storage of code chunk as const reference  <a href="classsnakemake__unit__tests_1_1rule__block.html#a3caa3e01a6b971a17402da027fca9273">More...</a><br /></td></tr>
<tr class="separator:a3caa3e01a6b971a17402da027fca9273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad0d8dab3d7390b316781fba25a187"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a27ad0d8dab3d7390b316781fba25a187">get_named_blocks</a> () const</td></tr>
<tr class="memdesc:a27ad0d8dab3d7390b316781fba25a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">get named blocks of rule body  <a href="classsnakemake__unit__tests_1_1rule__block.html#a27ad0d8dab3d7390b316781fba25a187">More...</a><br /></td></tr>
<tr class="separator:a27ad0d8dab3d7390b316781fba25a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382259a591a1f4c9345523b23de4f478"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a382259a591a1f4c9345523b23de4f478">get_local_indentation</a> () const</td></tr>
<tr class="memdesc:a382259a591a1f4c9345523b23de4f478"><td class="mdescLeft">&#160;</td><td class="mdescRight">get local indentation of rule block  <a href="classsnakemake__unit__tests_1_1rule__block.html#a382259a591a1f4c9345523b23de4f478">More...</a><br /></td></tr>
<tr class="separator:a382259a591a1f4c9345523b23de4f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1be741a981cae72e5975a19d906f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a1fa1be741a981cae72e5975a19d906f9">offer_base_rule_contents</a> (const std::string &amp;provider_name, const std::string &amp;block_name, const std::string &amp;block_values)</td></tr>
<tr class="memdesc:a1fa1be741a981cae72e5975a19d906f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide candidate base rule block definitions for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a1fa1be741a981cae72e5975a19d906f9">More...</a><br /></td></tr>
<tr class="separator:a1fa1be741a981cae72e5975a19d906f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a1519c228e377353bb2f3a1e9e418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a087a1519c228e377353bb2f3a1e9e418">add_code_chunk</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a087a1519c228e377353bb2f3a1e9e418"><td class="mdescLeft">&#160;</td><td class="mdescRight">manually inject code into this block  <a href="classsnakemake__unit__tests_1_1rule__block.html#a087a1519c228e377353bb2f3a1e9e418">More...</a><br /></td></tr>
<tr class="separator:a087a1519c228e377353bb2f3a1e9e418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e3182649715cc41e4426d5f80f67f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a1e2e3182649715cc41e4426d5f80f67f">operator==</a> (const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;obj) const</td></tr>
<tr class="memdesc:a1e2e3182649715cc41e4426d5f80f67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">test equality  <a href="classsnakemake__unit__tests_1_1rule__block.html#a1e2e3182649715cc41e4426d5f80f67f">More...</a><br /></td></tr>
<tr class="separator:a1e2e3182649715cc41e4426d5f80f67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4472fc8a2403a5ce4503483940542cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ae4472fc8a2403a5ce4503483940542cb">operator!=</a> (const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;obj) const</td></tr>
<tr class="memdesc:ae4472fc8a2403a5ce4503483940542cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">test inequality  <a href="classsnakemake__unit__tests_1_1rule__block.html#ae4472fc8a2403a5ce4503483940542cb">More...</a><br /></td></tr>
<tr class="separator:ae4472fc8a2403a5ce4503483940542cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8665be055b61187ab36df3b58ec108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a5c8665be055b61187ab36df3b58ec108">resolved</a> () const</td></tr>
<tr class="memdesc:a5c8665be055b61187ab36df3b58ec108"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the object's content needs a python pass to resolve  <a href="classsnakemake__unit__tests_1_1rule__block.html#a5c8665be055b61187ab36df3b58ec108">More...</a><br /></td></tr>
<tr class="separator:a5c8665be055b61187ab36df3b58ec108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad691440817a7ab6ddc3cc4d9cfc6d0d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ad691440817a7ab6ddc3cc4d9cfc6d0d8">included</a> () const</td></tr>
<tr class="memdesc:ad691440817a7ab6ddc3cc4d9cfc6d0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the object's contents should be included in the output  <a href="classsnakemake__unit__tests_1_1rule__block.html#ad691440817a7ab6ddc3cc4d9cfc6d0d8">More...</a><br /></td></tr>
<tr class="separator:ad691440817a7ab6ddc3cc4d9cfc6d0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cf041ce92abfdeb3a4c6e03f0b9abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ae9cf041ce92abfdeb3a4c6e03f0b9abe">set_resolution</a> (<a class="el" href="rule__block_8h.html#ae5c38f8cbf024e7fde6f4595a34a64e3">block_status</a> s)</td></tr>
<tr class="memdesc:ae9cf041ce92abfdeb3a4c6e03f0b9abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">override the current resolution status based on external logic  <a href="classsnakemake__unit__tests_1_1rule__block.html#ae9cf041ce92abfdeb3a4c6e03f0b9abe">More...</a><br /></td></tr>
<tr class="separator:ae9cf041ce92abfdeb3a4c6e03f0b9abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85bc99108fc5178100d17d2fcfe6dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rule__block_8h.html#ae5c38f8cbf024e7fde6f4595a34a64e3">block_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ae85bc99108fc5178100d17d2fcfe6dae">get_resolution_status</a> () const</td></tr>
<tr class="memdesc:ae85bc99108fc5178100d17d2fcfe6dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current resolution status  <a href="classsnakemake__unit__tests_1_1rule__block.html#ae85bc99108fc5178100d17d2fcfe6dae">More...</a><br /></td></tr>
<tr class="separator:ae85bc99108fc5178100d17d2fcfe6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1221b806b4a09c990e0b0e0c41c30d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aac1221b806b4a09c990e0b0e0c41c30d">set_interpreter_tag</a> (unsigned u)</td></tr>
<tr class="memdesc:aac1221b806b4a09c990e0b0e0c41c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the unique python tag for inclusion tracking  <a href="classsnakemake__unit__tests_1_1rule__block.html#aac1221b806b4a09c990e0b0e0c41c30d">More...</a><br /></td></tr>
<tr class="separator:aac1221b806b4a09c990e0b0e0c41c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a883957b638b6ed42aef5426f62f0e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ae9a883957b638b6ed42aef5426f62f0e">get_interpreter_tag</a> () const</td></tr>
<tr class="memdesc:ae9a883957b638b6ed42aef5426f62f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the unique python tag for inclusion tracking  <a href="classsnakemake__unit__tests_1_1rule__block.html#ae9a883957b638b6ed42aef5426f62f0e">More...</a><br /></td></tr>
<tr class="separator:ae9a883957b638b6ed42aef5426f62f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead538d30807b81125b41c734bc1088d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aead538d30807b81125b41c734bc1088d">report_python_logging_code</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aead538d30807b81125b41c734bc1088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">emit a python syntax reporting block to dummy file  <a href="classsnakemake__unit__tests_1_1rule__block.html#aead538d30807b81125b41c734bc1088d">More...</a><br /></td></tr>
<tr class="separator:aead538d30807b81125b41c734bc1088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2601453e4ef166e0ea70926801869504"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a2601453e4ef166e0ea70926801869504">update_resolution</a> (const std::map&lt; std::string, std::string &gt; &amp;tag_values)</td></tr>
<tr class="memdesc:a2601453e4ef166e0ea70926801869504"><td class="mdescLeft">&#160;</td><td class="mdescRight">using python tag output, update resolution status  <a href="classsnakemake__unit__tests_1_1rule__block.html#a2601453e4ef166e0ea70926801869504">More...</a><br /></td></tr>
<tr class="separator:a2601453e4ef166e0ea70926801869504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6433b428c06778b4fb4c9753692b84"><td class="memItemLeft" align="right" valign="top">const boost::filesystem::path &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a3e6433b428c06778b4fb4c9753692b84">get_resolved_included_filename</a> () const</td></tr>
<tr class="memdesc:a3e6433b428c06778b4fb4c9753692b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">for include statements, get actual filename for inclusion  <a href="classsnakemake__unit__tests_1_1rule__block.html#a3e6433b428c06778b4fb4c9753692b84">More...</a><br /></td></tr>
<tr class="separator:a3e6433b428c06778b4fb4c9753692b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05007968bfd8f9ea3c634d4a51e2f72b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a05007968bfd8f9ea3c634d4a51e2f72b">is_checkpoint</a> () const</td></tr>
<tr class="memdesc:a05007968bfd8f9ea3c634d4a51e2f72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">if this is a rule, is it a checkpoint  <a href="classsnakemake__unit__tests_1_1rule__block.html#a05007968bfd8f9ea3c634d4a51e2f72b">More...</a><br /></td></tr>
<tr class="separator:a05007968bfd8f9ea3c634d4a51e2f72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ba1d14788e7c063420302f4974642f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ac8ba1d14788e7c063420302f4974642f">set_checkpoint</a> (bool b)</td></tr>
<tr class="memdesc:ac8ba1d14788e7c063420302f4974642f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set checkpoint status  <a href="classsnakemake__unit__tests_1_1rule__block.html#ac8ba1d14788e7c063420302f4974642f">More...</a><br /></td></tr>
<tr class="separator:ac8ba1d14788e7c063420302f4974642f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f1e8b82df2cf9fafdbbf0a6146f343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a18f1e8b82df2cf9fafdbbf0a6146f343">report_rulesdot_rules</a> (std::map&lt; std::string, bool &gt; *target) const</td></tr>
<tr class="memdesc:a18f1e8b82df2cf9fafdbbf0a6146f343"><td class="mdescLeft">&#160;</td><td class="mdescRight">scan block contents for 'rules.' calls and report implicated rulenames  <a href="classsnakemake__unit__tests_1_1rule__block.html#a18f1e8b82df2cf9fafdbbf0a6146f343">More...</a><br /></td></tr>
<tr class="separator:a18f1e8b82df2cf9fafdbbf0a6146f343"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1b706d3d1999c8937faab48c28038545"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a1b706d3d1999c8937faab48c28038545">indentation</a> (unsigned count) const</td></tr>
<tr class="memdesc:a1b706d3d1999c8937faab48c28038545"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a string containing some number of whitespaces  <a href="classsnakemake__unit__tests_1_1rule__block.html#a1b706d3d1999c8937faab48c28038545">More...</a><br /></td></tr>
<tr class="separator:a1b706d3d1999c8937faab48c28038545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90782db2c2213aa8133e6daa478c6c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#ab90782db2c2213aa8133e6daa478c6c0">apply_indentation</a> (const std::string &amp;s, unsigned count) const</td></tr>
<tr class="memdesc:ab90782db2c2213aa8133e6daa478c6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace embedded newlines in a string with newlines plus indentation  <a href="classsnakemake__unit__tests_1_1rule__block.html#ab90782db2c2213aa8133e6daa478c6c0">More...</a><br /></td></tr>
<tr class="separator:ab90782db2c2213aa8133e6daa478c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="memItemLeft" align="right" valign="top"><a id="aa24047e29c6cdf6bbb50c7ed6d2f527a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aa24047e29c6cdf6bbb50c7ed6d2f527a">clear</a> ()</td></tr>
<tr class="memdesc:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear out internal storage <br /></td></tr>
<tr class="separator:aa24047e29c6cdf6bbb50c7ed6d2f527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2c3d50d1780b52a0189047637fed8dd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a2c3d50d1780b52a0189047637fed8dd0">_rule_name</a></td></tr>
<tr class="memdesc:a2c3d50d1780b52a0189047637fed8dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">declared rule name  <a href="classsnakemake__unit__tests_1_1rule__block.html#a2c3d50d1780b52a0189047637fed8dd0">More...</a><br /></td></tr>
<tr class="separator:a2c3d50d1780b52a0189047637fed8dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a22523a1aa4fa7a7675ee64129b1e1ce2">_base_rule_name</a></td></tr>
<tr class="memdesc:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">name of base rule for derived rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a22523a1aa4fa7a7675ee64129b1e1ce2">More...</a><br /></td></tr>
<tr class="separator:a22523a1aa4fa7a7675ee64129b1e1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6a9af37f46cac139f3c3ebb6579af7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a9f6a9af37f46cac139f3c3ebb6579af7">_rule_is_checkpoint</a></td></tr>
<tr class="memdesc:a9f6a9af37f46cac139f3c3ebb6579af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the chunk is a rule, whether the rule is a checkpoint  <a href="classsnakemake__unit__tests_1_1rule__block.html#a9f6a9af37f46cac139f3c3ebb6579af7">More...</a><br /></td></tr>
<tr class="separator:a9f6a9af37f46cac139f3c3ebb6579af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2c13d1921d6c5c31d507f346850767"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#aea2c13d1921d6c5c31d507f346850767">_named_blocks</a></td></tr>
<tr class="memdesc:aea2c13d1921d6c5c31d507f346850767"><td class="mdescLeft">&#160;</td><td class="mdescRight">arbitrary named blocks and their contents  <a href="classsnakemake__unit__tests_1_1rule__block.html#aea2c13d1921d6c5c31d507f346850767">More...</a><br /></td></tr>
<tr class="separator:aea2c13d1921d6c5c31d507f346850767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4a75de30ebdd1d00f76990337943e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a51a4a75de30ebdd1d00f76990337943e">_code_chunk</a></td></tr>
<tr class="memdesc:a51a4a75de30ebdd1d00f76990337943e"><td class="mdescLeft">&#160;</td><td class="mdescRight">arbitrary python code chunk that can exist between rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a51a4a75de30ebdd1d00f76990337943e">More...</a><br /></td></tr>
<tr class="separator:a51a4a75de30ebdd1d00f76990337943e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695111cc2a3a27df46bb5580625f82cd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a695111cc2a3a27df46bb5580625f82cd">_local_indentation</a></td></tr>
<tr class="memdesc:a695111cc2a3a27df46bb5580625f82cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">allow for local indentation of conditionally included rules  <a href="classsnakemake__unit__tests_1_1rule__block.html#a695111cc2a3a27df46bb5580625f82cd">More...</a><br /></td></tr>
<tr class="separator:a695111cc2a3a27df46bb5580625f82cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621b53c786b813b7610f1c929150b9e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rule__block_8h.html#ae5c38f8cbf024e7fde6f4595a34a64e3">block_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a621b53c786b813b7610f1c929150b9e0">_resolution</a></td></tr>
<tr class="memdesc:a621b53c786b813b7610f1c929150b9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">resolution status of block  <a href="classsnakemake__unit__tests_1_1rule__block.html#a621b53c786b813b7610f1c929150b9e0">More...</a><br /></td></tr>
<tr class="separator:a621b53c786b813b7610f1c929150b9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785f4c8b6848704f1f93b4df6204ec2a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a785f4c8b6848704f1f93b4df6204ec2a">_python_tag</a></td></tr>
<tr class="memdesc:a785f4c8b6848704f1f93b4df6204ec2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag for python interpreter tracking  <a href="classsnakemake__unit__tests_1_1rule__block.html#a785f4c8b6848704f1f93b4df6204ec2a">More...</a><br /></td></tr>
<tr class="separator:a785f4c8b6848704f1f93b4df6204ec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac93cfc421edfa61591208fac8a7166"><td class="memItemLeft" align="right" valign="top"><a id="a7ac93cfc421edfa61591208fac8a7166"></a>
boost::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1rule__block.html#a7ac93cfc421edfa61591208fac8a7166">_resolved_included_filename</a></td></tr>
<tr class="memdesc:a7ac93cfc421edfa61591208fac8a7166"><td class="mdescLeft">&#160;</td><td class="mdescRight">for include directives: resolved name of included file <br /></td></tr>
<tr class="separator:a7ac93cfc421edfa61591208fac8a7166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>command line argument parser using boost::program_options </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2122be784b8ecf4651a76a653b0306ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2122be784b8ecf4651a76a653b0306ea">&#9670;&nbsp;</a></span>rule_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">snakemake_unit_tests::rule_block::rule_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>existing rule block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a087a1519c228e377353bb2f3a1e9e418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087a1519c228e377353bb2f3a1e9e418">&#9670;&nbsp;</a></span>add_code_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::add_code_chunk </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>manually inject code into this block </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>code to inject</td></tr>
  </table>
  </dd>
</dl>
<p>required for the redesign of the parser </p>

</div>
</div>
<a id="ab90782db2c2213aa8133e6daa478c6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90782db2c2213aa8133e6daa478c6c0">&#9670;&nbsp;</a></span>apply_indentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::apply_indentation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replace embedded newlines in a string with newlines plus indentation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>input string, possibly with embedded newlines </td></tr>
    <tr><td class="paramname">count</td><td>total whitespace indentation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reformatted input string</dd></dl>
<p>this is intended for use with rule block contents, and as such does not interact with the implied newline at the end of the string </p>

</div>
</div>
<a id="a12e3501a0700e32515aef16647f71753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e3501a0700e32515aef16647f71753">&#9670;&nbsp;</a></span>consume_rule_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::consume_rule_contents </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>loaded_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>current_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>block_base_increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>having found a rule declaration, load its blocks </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loaded_lines</td><td>vector of snakemake lines to process </td></tr>
    <tr><td class="paramname">filename</td><td>name of the loaded snakemake file. only used for informative error messages </td></tr>
    <tr><td class="paramname">verbose</td><td>whether to report verbose logging output </td></tr>
    <tr><td class="paramname">current_line</td><td>currently probed line tracker </td></tr>
    <tr><td class="paramname">block_base_increment</td><td>indentation of block tag lines relative to parent rule declaration line (default is 4 with snakefmt) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether a rule was successfully loaded</dd></dl>
<p>block_base_increment added to allow grabbing block-like structures at global scope (e.g. 'wildcard_constraints:') </p>

</div>
</div>
<a id="ab65f435719bfb7e63869c881b589ded1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65f435719bfb7e63869c881b589ded1">&#9670;&nbsp;</a></span>contains_include_directive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::contains_include_directive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine whether this block contains something that looks like an include directive but that doesn't conform to basic include syntax </p>
<dl class="section return"><dt>Returns</dt><dd>whether a non-standard include directive is in effect </dd></dl>

</div>
</div>
<a id="a4c7bfd792416701392f04aa5ddcaa1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7bfd792416701392f04aa5ddcaa1bc">&#9670;&nbsp;</a></span>get_base_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; snakemake_unit_tests::rule_block::get_base_rule_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the name of the base rule for derived rules </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the base rule if applicable, or an empty string </dd></dl>

</div>
</div>
<a id="a3caa3e01a6b971a17402da027fca9273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caa3e01a6b971a17402da027fca9273">&#9670;&nbsp;</a></span>get_code_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; snakemake_unit_tests::rule_block::get_code_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get internal storage of code chunk as const reference </p>
<dl class="section return"><dt>Returns</dt><dd>code chunk as const reference </dd></dl>

</div>
</div>
<a id="ae696927452c2be2a023910739ec846a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae696927452c2be2a023910739ec846a7">&#9670;&nbsp;</a></span>get_filename_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::get_filename_expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract the filename expression from an include statement </p>
<dl class="section return"><dt>Returns</dt><dd>the filename expression from an include statement</dd></dl>
<p>the hope is to extract a python expression that the interpreter can report back on </p>

</div>
</div>
<a id="adc0e13d780edf9c03a2ddc203f372148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0e13d780edf9c03a2ddc203f372148">&#9670;&nbsp;</a></span>get_include_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::get_include_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine how much indentation an include directive enjoyed </p>
<dl class="section return"><dt>Returns</dt><dd>indentation of include directive </dd></dl>

</div>
</div>
<a id="ae9a883957b638b6ed42aef5426f62f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a883957b638b6ed42aef5426f62f0e">&#9670;&nbsp;</a></span>get_interpreter_tag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::get_interpreter_tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the unique python tag for inclusion tracking </p>
<dl class="section return"><dt>Returns</dt><dd>the unique python tag for inclusion tracking </dd></dl>

</div>
</div>
<a id="a382259a591a1f4c9345523b23de4f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382259a591a1f4c9345523b23de4f478">&#9670;&nbsp;</a></span>get_local_indentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::get_local_indentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get local indentation of rule block </p>
<dl class="section return"><dt>Returns</dt><dd>local indentation of rule block </dd></dl>

</div>
</div>
<a id="a27ad0d8dab3d7390b316781fba25a187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad0d8dab3d7390b316781fba25a187">&#9670;&nbsp;</a></span>get_named_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, std::string&gt;&amp; snakemake_unit_tests::rule_block::get_named_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get named blocks of rule body </p>
<dl class="section return"><dt>Returns</dt><dd>named blocks of rule body, or empty map </dd></dl>

</div>
</div>
<a id="ae85bc99108fc5178100d17d2fcfe6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85bc99108fc5178100d17d2fcfe6dae">&#9670;&nbsp;</a></span>get_resolution_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rule__block_8h.html#ae5c38f8cbf024e7fde6f4595a34a64e3">block_status</a> snakemake_unit_tests::rule_block::get_resolution_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the current resolution status </p>
<dl class="section return"><dt>Returns</dt><dd>the current resolution status </dd></dl>

</div>
</div>
<a id="a3e6433b428c06778b4fb4c9753692b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6433b428c06778b4fb4c9753692b84">&#9670;&nbsp;</a></span>get_resolved_included_filename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::filesystem::path&amp; snakemake_unit_tests::rule_block::get_resolved_included_filename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for include statements, get actual filename for inclusion </p>
<dl class="section return"><dt>Returns</dt><dd>resolved filename </dd></dl>

</div>
</div>
<a id="aef19d37e8073831c34fb2590674b4de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef19d37e8073831c34fb2590674b4de4">&#9670;&nbsp;</a></span>get_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; snakemake_unit_tests::rule_block::get_rule_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the name of the rule </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the rule</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>regex matching is currently borked, this entry may be garbage </dd></dl>

</div>
</div>
<a id="a501517c9b7fd13e0e4d716850a5cd04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501517c9b7fd13e0e4d716850a5cd04e">&#9670;&nbsp;</a></span>get_standard_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::get_standard_filename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the block is an include directive, get the file that is included </p>
<dl class="section return"><dt>Returns</dt><dd>the included filename </dd></dl>

</div>
</div>
<a id="ad691440817a7ab6ddc3cc4d9cfc6d0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad691440817a7ab6ddc3cc4d9cfc6d0d8">&#9670;&nbsp;</a></span>included()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::included </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the object's contents should be included in the output </p>
<dl class="section return"><dt>Returns</dt><dd>whether the object's contents should be included in the output </dd></dl>

</div>
</div>
<a id="a1b706d3d1999c8937faab48c28038545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b706d3d1999c8937faab48c28038545">&#9670;&nbsp;</a></span>indentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::indentation </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a string containing some number of whitespaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>total whitespace indentation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>formatted indentation whitespace </dd></dl>

</div>
</div>
<a id="a05007968bfd8f9ea3c634d4a51e2f72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05007968bfd8f9ea3c634d4a51e2f72b">&#9670;&nbsp;</a></span>is_checkpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::is_checkpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if this is a rule, is it a checkpoint </p>
<dl class="section return"><dt>Returns</dt><dd>whether, if a rule, this is a checkpoint</dd></dl>
<p>uninterpretable if not a rule </p>

</div>
</div>
<a id="a151f7493f2ecc40227a52812c76f7c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151f7493f2ecc40227a52812c76f7c5f">&#9670;&nbsp;</a></span>is_simple_include_directive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::is_simple_include_directive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine whether this block is a simple snakemake include directive </p>
<dl class="section return"><dt>Returns</dt><dd>whether the block is a simple include directive, hopefully </dd></dl>

</div>
</div>
<a id="ad96a6ee8aa9d2afad7a050cc2d7a1a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96a6ee8aa9d2afad7a050cc2d7a1a01">&#9670;&nbsp;</a></span>load_content_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::load_content_block </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>loaded_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>current_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a rule block or python chunk from a snakemake file vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loaded_lines</td><td>vector of snakemake file lines to process </td></tr>
    <tr><td class="paramname">filename</td><td>name of the loaded snakemake file. only used for informative error messages defaulting to 0 for standard file loads and incrementing by 4 for each level of indentation the include directive had within its python block </td></tr>
    <tr><td class="paramname">verbose</td><td>whether to report verbose logging output </td></tr>
    <tr><td class="paramname">current_line</td><td>currently probed line tracker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether a rule was successfully loaded</dd></dl>
<p>this function will parse out a single rule from a snakemake file. it is designed to be called until it returns false. </p>

</div>
</div>
<a id="a1fa1be741a981cae72e5975a19d906f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa1be741a981cae72e5975a19d906f9">&#9670;&nbsp;</a></span>offer_base_rule_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::offer_base_rule_contents </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>provider_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>block_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>block_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide candidate base rule block definitions for derived rules </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider_name</td><td>name of candidate base rule providing this information </td></tr>
    <tr><td class="paramname">block_name</td><td>name of block definition from the base rule </td></tr>
    <tr><td class="paramname">block_values</td><td>contents of block from the base rule</td></tr>
  </table>
  </dd>
</dl>
<p>for safety, the rule will check that such a suggestion is sane, and respond accordingly if not </p>

</div>
</div>
<a id="ae4472fc8a2403a5ce4503483940542cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4472fc8a2403a5ce4503483940542cb">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test inequality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>other <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html" title="command line argument parser using boost::program_options">rule_block</a> object to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether *this and obj contain the same contents</dd></dl>
<p>note that indentation level is irrelevant for this comparison </p>

</div>
</div>
<a id="a1e2e3182649715cc41e4426d5f80f67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e3182649715cc41e4426d5f80f67f">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html">rule_block</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test equality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>other <a class="el" href="classsnakemake__unit__tests_1_1rule__block.html" title="command line argument parser using boost::program_options">rule_block</a> object to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether *this and obj contain the same contents</dd></dl>
<p>note that indentation level is irrelevant for this comparison </p>

</div>
</div>
<a id="aa3429e0b3dde7eaeb99520dd629d6ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3429e0b3dde7eaeb99520dd629d6ba4">&#9670;&nbsp;</a></span>print_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::print_contents </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>report mildly formatted contents to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>an open stream to which to write formatted contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aead538d30807b81125b41c734bc1088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead538d30807b81125b41c734bc1088d">&#9670;&nbsp;</a></span>report_python_logging_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::report_python_logging_code </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>emit a python syntax reporting block to dummy file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>open output stream for reporting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f1e8b82df2cf9fafdbbf0a6146f343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f1e8b82df2cf9fafdbbf0a6146f343">&#9670;&nbsp;</a></span>report_rulesdot_rules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::report_rulesdot_rules </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, bool &gt; *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scan block contents for 'rules.' calls and report implicated rulenames </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>where to store any detected rules </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c8665be055b61187ab36df3b58ec108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8665be055b61187ab36df3b58ec108">&#9670;&nbsp;</a></span>resolved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::resolved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the object's content needs a python pass to resolve </p>
<dl class="section return"><dt>Returns</dt><dd>whether the object's content needs a python pass to resolve </dd></dl>

</div>
</div>
<a id="ab4f0b8b567ea6fd0573f986a16fb107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f0b8b567ea6fd0573f986a16fb107d">&#9670;&nbsp;</a></span>set_base_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_base_rule_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the name of the base rule for derived rules </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new name of base rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8ba1d14788e7c063420302f4974642f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba1d14788e7c063420302f4974642f">&#9670;&nbsp;</a></span>set_checkpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_checkpoint </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set checkpoint status </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>new setting for checkpoint indicator</td></tr>
  </table>
  </dd>
</dl>
<p>uninterpretable if not a rule </p>

</div>
</div>
<a id="aac1221b806b4a09c990e0b0e0c41c30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1221b806b4a09c990e0b0e0c41c30d">&#9670;&nbsp;</a></span>set_interpreter_tag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_interpreter_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the unique python tag for inclusion tracking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>new value for unique python tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9cf041ce92abfdeb3a4c6e03f0b9abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cf041ce92abfdeb3a4c6e03f0b9abe">&#9670;&nbsp;</a></span>set_resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rule__block_8h.html#ae5c38f8cbf024e7fde6f4595a34a64e3">block_status</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>override the current resolution status based on external logic </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new value for resolution status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e39b5aaea4f9b7a7e96cc3d0a5dba50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e39b5aaea4f9b7a7e96cc3d0a5dba50">&#9670;&nbsp;</a></span>set_rule_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::rule_block::set_rule_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the name of the rule </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new name of rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2601453e4ef166e0ea70926801869504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2601453e4ef166e0ea70926801869504">&#9670;&nbsp;</a></span>update_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::update_resolution </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag_values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>using python tag output, update resolution status </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_values</td><td>loaded key(:value) pairs from python output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the current rule allows downstream logic to continue </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a22523a1aa4fa7a7675ee64129b1e1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22523a1aa4fa7a7675ee64129b1e1ce2">&#9670;&nbsp;</a></span>_base_rule_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::_base_rule_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>name of base rule for derived rules </p>
<p>only a snakemake 6.0+ feature. for these rules, some entries will be populated later </p>

</div>
</div>
<a id="a51a4a75de30ebdd1d00f76990337943e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a4a75de30ebdd1d00f76990337943e">&#9670;&nbsp;</a></span>_code_chunk</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; snakemake_unit_tests::rule_block::_code_chunk</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>arbitrary python code chunk that can exist between rules </p>
<p>this wasn't the original intention of this class, but rather than deal with derived classes and other nonsense, since arbitrary code blocks follow the same logic as rule blocks, they can just be stored in their own copy of this class </p>

</div>
</div>
<a id="a695111cc2a3a27df46bb5580625f82cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695111cc2a3a27df46bb5580625f82cd">&#9670;&nbsp;</a></span>_local_indentation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::_local_indentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allow for local indentation of conditionally included rules </p>
<p>rules included within python blocks should temporarily have escalated indentation, which determines the end of the rule block later in the file </p>

</div>
</div>
<a id="aea2c13d1921d6c5c31d507f346850767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2c13d1921d6c5c31d507f346850767">&#9670;&nbsp;</a></span>_named_blocks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; snakemake_unit_tests::rule_block::_named_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>arbitrary named blocks and their contents </p>
<p>input and output blocks need to be handled specially, but the others can be arbitrarily specified. </p>

</div>
</div>
<a id="a785f4c8b6848704f1f93b4df6204ec2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785f4c8b6848704f1f93b4df6204ec2a">&#9670;&nbsp;</a></span>_python_tag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned snakemake_unit_tests::rule_block::_python_tag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tag for python interpreter tracking </p>
<p>this is just a unique number that will be emitted to the python tracking pass </p>

</div>
</div>
<a id="a621b53c786b813b7610f1c929150b9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621b53c786b813b7610f1c929150b9e0">&#9670;&nbsp;</a></span>_resolution</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rule__block_8h.html#ae5c38f8cbf024e7fde6f4595a34a64e3">block_status</a> snakemake_unit_tests::rule_block::_resolution</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resolution status of block </p>
<p>this can be: UNRESOLVED, RESOLVED_INCLUDED, RESOLVED_EXCLUDED </p>

</div>
</div>
<a id="a9f6a9af37f46cac139f3c3ebb6579af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6a9af37f46cac139f3c3ebb6579af7">&#9670;&nbsp;</a></span>_rule_is_checkpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::rule_block::_rule_is_checkpoint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the chunk is a rule, whether the rule is a checkpoint </p>
<p>note that there are indications (28 Apr 2021) of checkpoints not functioning on cluster systems, so their use is somewhat dubious </p>

</div>
</div>
<a id="a2c3d50d1780b52a0189047637fed8dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3d50d1780b52a0189047637fed8dd0">&#9670;&nbsp;</a></span>_rule_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::rule_block::_rule_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>declared rule name </p>
<p>needs to be unique, but should be if the snakemake run was successful </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>snakemake_unit_tests/<a class="el" href="rule__block_8h_source.html">rule_block.h</a></li>
<li>snakemake_unit_tests/<a class="el" href="rule__block_8cc.html">rule_block.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
