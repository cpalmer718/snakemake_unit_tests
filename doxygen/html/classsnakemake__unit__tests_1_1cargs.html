<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snakemake_unit_tests: snakemake_unit_tests::cargs Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">snakemake_unit_tests
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Replicate snakemake --generate-unit-tests functionality with the added benefit of actually working</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>snakemake_unit_tests</b></li><li class="navelem"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html">cargs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">snakemake_unit_tests::cargs Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>command line argument parser using boost::program_options  
 <a href="classsnakemake__unit__tests_1_1cargs.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cargs_8h_source.html">cargs.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0da51c94b8bd2de6b30e57aad23945c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a0da51c94b8bd2de6b30e57aad23945c7">cargs</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a0da51c94b8bd2de6b30e57aad23945c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with program arguments  <a href="classsnakemake__unit__tests_1_1cargs.html#a0da51c94b8bd2de6b30e57aad23945c7">More...</a><br /></td></tr>
<tr class="separator:a0da51c94b8bd2de6b30e57aad23945c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760c43826e1f820e9ed1e42cafe284de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a760c43826e1f820e9ed1e42cafe284de">cargs</a> (const <a class="el" href="classsnakemake__unit__tests_1_1cargs.html">cargs</a> &amp;obj)</td></tr>
<tr class="memdesc:a760c43826e1f820e9ed1e42cafe284de"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classsnakemake__unit__tests_1_1cargs.html#a760c43826e1f820e9ed1e42cafe284de">More...</a><br /></td></tr>
<tr class="separator:a760c43826e1f820e9ed1e42cafe284de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed237297a9863ebe9dbdd18e6285507"><td class="memItemLeft" align="right" valign="top"><a id="a6ed237297a9863ebe9dbdd18e6285507"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a6ed237297a9863ebe9dbdd18e6285507">~cargs</a> ()  throw ()</td></tr>
<tr class="memdesc:a6ed237297a9863ebe9dbdd18e6285507"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a6ed237297a9863ebe9dbdd18e6285507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ed23df6e8352dcd2a2607688bb2180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#aa6ed23df6e8352dcd2a2607688bb2180">initialize_options</a> ()</td></tr>
<tr class="memdesc:aa6ed23df6e8352dcd2a2607688bb2180"><td class="mdescLeft">&#160;</td><td class="mdescRight">set user help documentation and default values for parameters as needed  <a href="classsnakemake__unit__tests_1_1cargs.html#aa6ed23df6e8352dcd2a2607688bb2180">More...</a><br /></td></tr>
<tr class="separator:aa6ed23df6e8352dcd2a2607688bb2180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f28c79bacf37a3cf205061251eb41ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsnakemake__unit__tests_1_1params.html">params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a7f28c79bacf37a3cf205061251eb41ac">set_parameters</a> () const</td></tr>
<tr class="memdesc:a7f28c79bacf37a3cf205061251eb41ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">deal with parameter settings, across CLI and config yaml  <a href="classsnakemake__unit__tests_1_1cargs.html#a7f28c79bacf37a3cf205061251eb41ac">More...</a><br /></td></tr>
<tr class="separator:a7f28c79bacf37a3cf205061251eb41ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022cc6ee8a36c60f09e228c494719d64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a022cc6ee8a36c60f09e228c494719d64">help</a> () const</td></tr>
<tr class="memdesc:a022cc6ee8a36c60f09e228c494719d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether the user has requested help documentation  <a href="classsnakemake__unit__tests_1_1cargs.html#a022cc6ee8a36c60f09e228c494719d64">More...</a><br /></td></tr>
<tr class="separator:a022cc6ee8a36c60f09e228c494719d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2c9af584be03ec588cf57940e8545e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a3e2c9af584be03ec588cf57940e8545e">get_config_yaml</a> () const</td></tr>
<tr class="memdesc:a3e2c9af584be03ec588cf57940e8545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get user-specified config yaml file, containing all the various parameters they've specified so they don't have to write out the horrible command line call each time  <a href="classsnakemake__unit__tests_1_1cargs.html#a3e2c9af584be03ec588cf57940e8545e">More...</a><br /></td></tr>
<tr class="separator:a3e2c9af584be03ec588cf57940e8545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79c72f68e8a91cc0bbe146bdaeb14a2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#af79c72f68e8a91cc0bbe146bdaeb14a2">get_snakefile</a> () const</td></tr>
<tr class="memdesc:af79c72f68e8a91cc0bbe146bdaeb14a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the top-level snakefile used for the full workflow  <a href="classsnakemake__unit__tests_1_1cargs.html#af79c72f68e8a91cc0bbe146bdaeb14a2">More...</a><br /></td></tr>
<tr class="separator:af79c72f68e8a91cc0bbe146bdaeb14a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456a635b99845592c19f842a2e329231"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a456a635b99845592c19f842a2e329231">get_snakemake_log</a> () const</td></tr>
<tr class="memdesc:a456a635b99845592c19f842a2e329231"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the snakemake log for the successful pipeline run that needs unit tests  <a href="classsnakemake__unit__tests_1_1cargs.html#a456a635b99845592c19f842a2e329231">More...</a><br /></td></tr>
<tr class="separator:a456a635b99845592c19f842a2e329231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b41f5ea298bdf6ab55ce8826db360"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a278b41f5ea298bdf6ab55ce8826db360">get_output_test_dir</a> () const</td></tr>
<tr class="memdesc:a278b41f5ea298bdf6ab55ce8826db360"><td class="mdescLeft">&#160;</td><td class="mdescRight">get top-level directory under which tests should be installed  <a href="classsnakemake__unit__tests_1_1cargs.html#a278b41f5ea298bdf6ab55ce8826db360">More...</a><br /></td></tr>
<tr class="separator:a278b41f5ea298bdf6ab55ce8826db360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56029082ac7b6294d67859c666d9e498"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a56029082ac7b6294d67859c666d9e498">get_pipeline_dir</a> () const</td></tr>
<tr class="memdesc:a56029082ac7b6294d67859c666d9e498"><td class="mdescLeft">&#160;</td><td class="mdescRight">get top-level directory under which actual pipeline was run  <a href="classsnakemake__unit__tests_1_1cargs.html#a56029082ac7b6294d67859c666d9e498">More...</a><br /></td></tr>
<tr class="separator:a56029082ac7b6294d67859c666d9e498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a443bcd3356618fb16f508da84b7654"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a6a443bcd3356618fb16f508da84b7654">get_inst_dir</a> () const</td></tr>
<tr class="memdesc:a6a443bcd3356618fb16f508da84b7654"><td class="mdescLeft">&#160;</td><td class="mdescRight">get path to inst directory for this copy of snakemake_unit_tests  <a href="classsnakemake__unit__tests_1_1cargs.html#a6a443bcd3356618fb16f508da84b7654">More...</a><br /></td></tr>
<tr class="separator:a6a443bcd3356618fb16f508da84b7654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8a0de7bcae0eeeb2f5e24fc078a140"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a4c8a0de7bcae0eeeb2f5e24fc078a140">get_added_files</a> () const</td></tr>
<tr class="memdesc:a4c8a0de7bcae0eeeb2f5e24fc078a140"><td class="mdescLeft">&#160;</td><td class="mdescRight">get optional multiple files (with relative paths) that will be installed alongside each unit test  <a href="classsnakemake__unit__tests_1_1cargs.html#a4c8a0de7bcae0eeeb2f5e24fc078a140">More...</a><br /></td></tr>
<tr class="separator:a4c8a0de7bcae0eeeb2f5e24fc078a140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08950dfa9e3b0b90394963f86d34344"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#aa08950dfa9e3b0b90394963f86d34344">get_added_directories</a> () const</td></tr>
<tr class="memdesc:aa08950dfa9e3b0b90394963f86d34344"><td class="mdescLeft">&#160;</td><td class="mdescRight">get optional multiple directories (with relative paths) that will be installed alongside each unit test  <a href="classsnakemake__unit__tests_1_1cargs.html#aa08950dfa9e3b0b90394963f86d34344">More...</a><br /></td></tr>
<tr class="separator:aa08950dfa9e3b0b90394963f86d34344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e83b9c67fc3ee8713435c5978d5b063"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a6e83b9c67fc3ee8713435c5978d5b063">get_exclude_rules</a> () const</td></tr>
<tr class="memdesc:a6e83b9c67fc3ee8713435c5978d5b063"><td class="mdescLeft">&#160;</td><td class="mdescRight">get optional rule names to exclude from testing  <a href="classsnakemake__unit__tests_1_1cargs.html#a6e83b9c67fc3ee8713435c5978d5b063">More...</a><br /></td></tr>
<tr class="separator:a6e83b9c67fc3ee8713435c5978d5b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89eba739d1cbc9eac095e7989c00d8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#ac89eba739d1cbc9eac095e7989c00d8a">update_all</a> () const</td></tr>
<tr class="memdesc:ac89eba739d1cbc9eac095e7989c00d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get user flag for updating all parts of unit tests  <a href="classsnakemake__unit__tests_1_1cargs.html#ac89eba739d1cbc9eac095e7989c00d8a">More...</a><br /></td></tr>
<tr class="separator:ac89eba739d1cbc9eac095e7989c00d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e6b64164687848fe05bd06b8cd4f07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a95e6b64164687848fe05bd06b8cd4f07">update_snakefiles</a> () const</td></tr>
<tr class="memdesc:a95e6b64164687848fe05bd06b8cd4f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">get user flag for updating existing tests in place (snakefiles only)  <a href="classsnakemake__unit__tests_1_1cargs.html#a95e6b64164687848fe05bd06b8cd4f07">More...</a><br /></td></tr>
<tr class="separator:a95e6b64164687848fe05bd06b8cd4f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc9bee27294c2cc8ac3423954749964"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#aecc9bee27294c2cc8ac3423954749964">update_added_content</a> () const</td></tr>
<tr class="memdesc:aecc9bee27294c2cc8ac3423954749964"><td class="mdescLeft">&#160;</td><td class="mdescRight">get user flag for updating added files and directories in place  <a href="classsnakemake__unit__tests_1_1cargs.html#aecc9bee27294c2cc8ac3423954749964">More...</a><br /></td></tr>
<tr class="separator:aecc9bee27294c2cc8ac3423954749964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a00a9c0db47315111e027b5e43dfce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a08a00a9c0db47315111e027b5e43dfce">update_inputs</a> () const</td></tr>
<tr class="memdesc:a08a00a9c0db47315111e027b5e43dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">get user flag for updating unit tests' inputs  <a href="classsnakemake__unit__tests_1_1cargs.html#a08a00a9c0db47315111e027b5e43dfce">More...</a><br /></td></tr>
<tr class="separator:a08a00a9c0db47315111e027b5e43dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48364153c7fe7da02f0a0736107a8634"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a48364153c7fe7da02f0a0736107a8634">update_outputs</a> () const</td></tr>
<tr class="memdesc:a48364153c7fe7da02f0a0736107a8634"><td class="mdescLeft">&#160;</td><td class="mdescRight">get user flag for updating unit tests' outputs  <a href="classsnakemake__unit__tests_1_1cargs.html#a48364153c7fe7da02f0a0736107a8634">More...</a><br /></td></tr>
<tr class="separator:a48364153c7fe7da02f0a0736107a8634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01a5f0457c93e52bac00ec280d61f58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#ac01a5f0457c93e52bac00ec280d61f58">update_pytest</a> () const</td></tr>
<tr class="memdesc:ac01a5f0457c93e52bac00ec280d61f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">get user flag for updating pytest infrastructure  <a href="classsnakemake__unit__tests_1_1cargs.html#ac01a5f0457c93e52bac00ec280d61f58">More...</a><br /></td></tr>
<tr class="separator:ac01a5f0457c93e52bac00ec280d61f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a59ceee21f04905a7dc5eb6cf9f63a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a03a59ceee21f04905a7dc5eb6cf9f63a">verbose</a> () const</td></tr>
<tr class="memdesc:a03a59ceee21f04905a7dc5eb6cf9f63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether the user has requested verbose logging output  <a href="classsnakemake__unit__tests_1_1cargs.html#a03a59ceee21f04905a7dc5eb6cf9f63a">More...</a><br /></td></tr>
<tr class="separator:a03a59ceee21f04905a7dc5eb6cf9f63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0724bc8922092911d533d126768f71e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#ad0724bc8922092911d533d126768f71e">compute_flag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:ad0724bc8922092911d533d126768f71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find status of arbitrary flag  <a href="classsnakemake__unit__tests_1_1cargs.html#ad0724bc8922092911d533d126768f71e">More...</a><br /></td></tr>
<tr class="separator:ad0724bc8922092911d533d126768f71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe6deb54d0c4875e7b51c23a54deb1d"><td class="memTemplParams" colspan="2">template&lt;class value_type &gt; </td></tr>
<tr class="memitem:a6fe6deb54d0c4875e7b51c23a54deb1d"><td class="memTemplItemLeft" align="right" valign="top">value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a6fe6deb54d0c4875e7b51c23a54deb1d">compute_parameter</a> (const std::string &amp;tag, bool optional=false) const</td></tr>
<tr class="memdesc:a6fe6deb54d0c4875e7b51c23a54deb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find value of arbitrary parameter  <a href="classsnakemake__unit__tests_1_1cargs.html#a6fe6deb54d0c4875e7b51c23a54deb1d">More...</a><br /></td></tr>
<tr class="separator:a6fe6deb54d0c4875e7b51c23a54deb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a26e90723123d7318296b1a120b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#aa50a26e90723123d7318296b1a120b65">print_help</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:aa50a26e90723123d7318296b1a120b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">report help documentation to arbitrary output stream  <a href="classsnakemake__unit__tests_1_1cargs.html#aa50a26e90723123d7318296b1a120b65">More...</a><br /></td></tr>
<tr class="separator:aa50a26e90723123d7318296b1a120b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a096a22cd763f374b370a05e358d6c0f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a096a22cd763f374b370a05e358d6c0f9">cargs</a> ()</td></tr>
<tr class="memdesc:a096a22cd763f374b370a05e358d6c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classsnakemake__unit__tests_1_1cargs.html#a096a22cd763f374b370a05e358d6c0f9">More...</a><br /></td></tr>
<tr class="separator:a096a22cd763f374b370a05e358d6c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940197b74bb1793509c339387a4730c7"><td class="memItemLeft" align="right" valign="top">boost::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a940197b74bb1793509c339387a4730c7">override_if_specified</a> (const std::string &amp;cli_entry, const boost::filesystem::path &amp;params_entry) const</td></tr>
<tr class="memdesc:a940197b74bb1793509c339387a4730c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the first parameter is nonempty, return it; otherwise return the second  <a href="classsnakemake__unit__tests_1_1cargs.html#a940197b74bb1793509c339387a4730c7">More...</a><br /></td></tr>
<tr class="separator:a940197b74bb1793509c339387a4730c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b20118f204085dd8f47e4db648c722"><td class="memTemplParams" colspan="2">template&lt;class value_type &gt; </td></tr>
<tr class="memitem:a47b20118f204085dd8f47e4db648c722"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a47b20118f204085dd8f47e4db648c722">add_contents</a> (const std::vector&lt; std::string &gt; &amp;cli_entries, std::vector&lt; value_type &gt; *params_entries) const</td></tr>
<tr class="memdesc:a47b20118f204085dd8f47e4db648c722"><td class="mdescLeft">&#160;</td><td class="mdescRight">append any CLI entries for a multitoken parameter to those already found in the config yaml  <a href="classsnakemake__unit__tests_1_1cargs.html#a47b20118f204085dd8f47e4db648c722">More...</a><br /></td></tr>
<tr class="separator:a47b20118f204085dd8f47e4db648c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01412612909d772f3dc8f0cbc5832365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a01412612909d772f3dc8f0cbc5832365">check_nonempty</a> (const boost::filesystem::path &amp;p, const std::string &amp;msg) const</td></tr>
<tr class="memdesc:a01412612909d772f3dc8f0cbc5832365"><td class="mdescLeft">&#160;</td><td class="mdescRight">make sure a path isn't just an empty string  <a href="classsnakemake__unit__tests_1_1cargs.html#a01412612909d772f3dc8f0cbc5832365">More...</a><br /></td></tr>
<tr class="separator:a01412612909d772f3dc8f0cbc5832365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8611545c69ac74ebb94156fd1d0fd021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a8611545c69ac74ebb94156fd1d0fd021">check_regular_file</a> (const boost::filesystem::path &amp;p, const boost::filesystem::path &amp;prefix, const std::string &amp;msg) const</td></tr>
<tr class="memdesc:a8611545c69ac74ebb94156fd1d0fd021"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a path, enforce it being a regular file  <a href="classsnakemake__unit__tests_1_1cargs.html#a8611545c69ac74ebb94156fd1d0fd021">More...</a><br /></td></tr>
<tr class="separator:a8611545c69ac74ebb94156fd1d0fd021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133690de88650eccb68af1281720cdb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a133690de88650eccb68af1281720cdb8">check_and_fix_dir</a> (boost::filesystem::path *p, const boost::filesystem::path &amp;prefix, const std::string &amp;msg) const</td></tr>
<tr class="memdesc:a133690de88650eccb68af1281720cdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a path, enforce it being a directory, and gently clean up its format  <a href="classsnakemake__unit__tests_1_1cargs.html#a133690de88650eccb68af1281720cdb8">More...</a><br /></td></tr>
<tr class="separator:a133690de88650eccb68af1281720cdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58251551386f449835aa166dfc788a39"><td class="memTemplParams" colspan="2">template&lt;class value_type &gt; </td></tr>
<tr class="memitem:a58251551386f449835aa166dfc788a39"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a58251551386f449835aa166dfc788a39">vector_convert</a> (const std::vector&lt; std::string &gt; &amp;vec) const</td></tr>
<tr class="memdesc:a58251551386f449835aa166dfc788a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast entries of a vector into something else  <a href="classsnakemake__unit__tests_1_1cargs.html#a58251551386f449835aa166dfc788a39">More...</a><br /></td></tr>
<tr class="separator:a58251551386f449835aa166dfc788a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4ff24e6dc87d0b6f8388b723202e6884"><td class="memItemLeft" align="right" valign="top"><a id="a4ff24e6dc87d0b6f8388b723202e6884"></a>
boost::program_options::options_description&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#a4ff24e6dc87d0b6f8388b723202e6884">_desc</a></td></tr>
<tr class="memdesc:a4ff24e6dc87d0b6f8388b723202e6884"><td class="mdescLeft">&#160;</td><td class="mdescRight">help documentation string <br /></td></tr>
<tr class="separator:a4ff24e6dc87d0b6f8388b723202e6884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed0d9bcb95dd36ce8b781505f87e2f9"><td class="memItemLeft" align="right" valign="top"><a id="aeed0d9bcb95dd36ce8b781505f87e2f9"></a>
boost::program_options::variables_map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsnakemake__unit__tests_1_1cargs.html#aeed0d9bcb95dd36ce8b781505f87e2f9">_vm</a></td></tr>
<tr class="memdesc:aeed0d9bcb95dd36ce8b781505f87e2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">storage of parsed command line settings <br /></td></tr>
<tr class="separator:aeed0d9bcb95dd36ce8b781505f87e2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>command line argument parser using boost::program_options </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0da51c94b8bd2de6b30e57aad23945c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da51c94b8bd2de6b30e57aad23945c7">&#9670;&nbsp;</a></span>cargs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">snakemake_unit_tests::cargs::cargs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor with program arguments </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>number of arguments including program name </td></tr>
    <tr><td class="paramname">argv</td><td>string array containing actual arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a760c43826e1f820e9ed1e42cafe284de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760c43826e1f820e9ed1e42cafe284de">&#9670;&nbsp;</a></span>cargs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">snakemake_unit_tests::cargs::cargs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsnakemake__unit__tests_1_1cargs.html">cargs</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>existing cargs object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a096a22cd763f374b370a05e358d6c0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096a22cd763f374b370a05e358d6c0f9">&#9670;&nbsp;</a></span>cargs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">snakemake_unit_tests::cargs::cargs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>
<dl class="section warning"><dt>Warning</dt><dd>disabled </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47b20118f204085dd8f47e4db648c722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b20118f204085dd8f47e4db648c722">&#9670;&nbsp;</a></span>add_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::cargs::add_contents </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cli_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; value_type &gt; *&#160;</td>
          <td class="paramname"><em>params_entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append any CLI entries for a multitoken parameter to those already found in the config yaml </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>class to cast command line strings into (can just be strings) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cli_entries</td><td>values for the parameter found on the command line </td></tr>
    <tr><td class="paramname">params_entries</td><td>values for the parameter found in the config yaml </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133690de88650eccb68af1281720cdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133690de88650eccb68af1281720cdb8">&#9670;&nbsp;</a></span>check_and_fix_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::cargs::check_and_fix_dir </td>
          <td>(</td>
          <td class="paramtype">boost::filesystem::path *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>given a path, enforce it being a directory, and gently clean up its format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>input candidate directory </td></tr>
    <tr><td class="paramname">prefix</td><td>optional prefix for actual directory; can be empty </td></tr>
    <tr><td class="paramname">msg</td><td>name of parameter flag for error messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01412612909d772f3dc8f0cbc5832365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01412612909d772f3dc8f0cbc5832365">&#9670;&nbsp;</a></span>check_nonempty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::cargs::check_nonempty </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make sure a path isn't just an empty string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>path to check </td></tr>
    <tr><td class="paramname">msg</td><td>name of parameter flag for error messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8611545c69ac74ebb94156fd1d0fd021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8611545c69ac74ebb94156fd1d0fd021">&#9670;&nbsp;</a></span>check_regular_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::cargs::check_regular_file </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>given a path, enforce it being a regular file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>input candidate file </td></tr>
    <tr><td class="paramname">prefix</td><td>optional prefix for actual file; can be empty </td></tr>
    <tr><td class="paramname">msg</td><td>name of parameter flag for error messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0724bc8922092911d533d126768f71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0724bc8922092911d533d126768f71e">&#9670;&nbsp;</a></span>compute_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::compute_flag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find status of arbitrary flag </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the flag is set</dd></dl>
<p>This is the underlying accessor function used by the custom flag accessors, and can be used for arbitrary flag additions if you don't want to type out the custom access functions or want to allow dynamic specification from a config file. </p>

</div>
</div>
<a id="a6fe6deb54d0c4875e7b51c23a54deb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe6deb54d0c4875e7b51c23a54deb1d">&#9670;&nbsp;</a></span>compute_parameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type snakemake_unit_tests::cargs::compute_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optional</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find value of arbitrary parameter </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>class to which the value should be cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name of parameter </td></tr>
    <tr><td class="paramname">optional</td><td>whether the parameter should be allowed to be unset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of parameter if specified</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>throws exception if parameter was not set and had no default </dd></dl>

</div>
</div>
<a id="aa08950dfa9e3b0b90394963f86d34344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08950dfa9e3b0b90394963f86d34344">&#9670;&nbsp;</a></span>get_added_directories()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; snakemake_unit_tests::cargs::get_added_directories </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get optional multiple directories (with relative paths) that will be installed alongside each unit test </p>
<dl class="section return"><dt>Returns</dt><dd>all provided relative directories (if any) in a string vector</dd></dl>
<p>This flag can be specified multiple times, or none. Note that the intention is for this option to be unnecessary, but it's exposed as an option just in case people come up with corner cases that the main logic cannot handle </p>

</div>
</div>
<a id="a4c8a0de7bcae0eeeb2f5e24fc078a140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8a0de7bcae0eeeb2f5e24fc078a140">&#9670;&nbsp;</a></span>get_added_files()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; snakemake_unit_tests::cargs::get_added_files </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get optional multiple files (with relative paths) that will be installed alongside each unit test </p>
<dl class="section return"><dt>Returns</dt><dd>all provided relative paths (if any) in a string vector</dd></dl>
<p>This flag can be specified multiple times, or none. Note that the intention is for this option to be unnecessary, but it's exposed as an option just in case people come up with corner cases that the main logic cannot handle </p>

</div>
</div>
<a id="a3e2c9af584be03ec588cf57940e8545e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2c9af584be03ec588cf57940e8545e">&#9670;&nbsp;</a></span>get_config_yaml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::cargs::get_config_yaml </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get user-specified config yaml file, containing all the various parameters they've specified so they don't have to write out the horrible command line call each time </p>
<dl class="section return"><dt>Returns</dt><dd>string filename of config yaml file </dd></dl>

</div>
</div>
<a id="a6e83b9c67fc3ee8713435c5978d5b063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e83b9c67fc3ee8713435c5978d5b063">&#9670;&nbsp;</a></span>get_exclude_rules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; snakemake_unit_tests::cargs::get_exclude_rules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get optional rule names to exclude from testing </p>
<dl class="section return"><dt>Returns</dt><dd>vector of all provided rules to exclude from test output </dd></dl>

</div>
</div>
<a id="a6a443bcd3356618fb16f508da84b7654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a443bcd3356618fb16f508da84b7654">&#9670;&nbsp;</a></span>get_inst_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::cargs::get_inst_dir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get path to inst directory for this copy of snakemake_unit_tests </p>
<dl class="section return"><dt>Returns</dt><dd>path to (including 'inst') inst directory from snakemake_unit_tests repo</dd></dl>
<p>once this is bundled for conda, this will default to $CONDA_PREFIX/share/snakemake_unit_tests/inst and the user's life will improve concomitantly. </p>

</div>
</div>
<a id="a278b41f5ea298bdf6ab55ce8826db360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278b41f5ea298bdf6ab55ce8826db360">&#9670;&nbsp;</a></span>get_output_test_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::cargs::get_output_test_dir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get top-level directory under which tests should be installed </p>
<dl class="section return"><dt>Returns</dt><dd>top-level test directory</dd></dl>
<p>as of this writing (March 2021), the default value for this in snakemake is '.tests' and that default is carried over here </p>

</div>
</div>
<a id="a56029082ac7b6294d67859c666d9e498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56029082ac7b6294d67859c666d9e498">&#9670;&nbsp;</a></span>get_pipeline_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::cargs::get_pipeline_dir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get top-level directory under which actual pipeline was run </p>
<dl class="section return"><dt>Returns</dt><dd>top-level run directory</dd></dl>
<p>this parameter is optional. if not specified, it will be computed as the directory above the one the Snakefile (specified from &ndash;snakefile). this assumes therefore that the pipeline is configured such that the top-level snakefile is installed in ~/workflow.</p>
<p>if specified, be cautious to ensure that this directory and the snakefile are provided from corresponding pipeline installations, or undefined behaviors may occur. but you can use this to provide base pipeline directories for non-compliant (but still valid) snakemake configurations, such as when the file is in ~/Snakefile instead of ~/workflow/Snakefile. </p>

</div>
</div>
<a id="af79c72f68e8a91cc0bbe146bdaeb14a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79c72f68e8a91cc0bbe146bdaeb14a2">&#9670;&nbsp;</a></span>get_snakefile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::cargs::get_snakefile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the top-level snakefile used for the full workflow </p>
<dl class="section return"><dt>Returns</dt><dd>name of and path to snakefile as a string</dd></dl>
<p>this just points to the top-level snakefile. any modularized rules in secondary snakefiles are loaded in automatically </p>

</div>
</div>
<a id="a456a635b99845592c19f842a2e329231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456a635b99845592c19f842a2e329231">&#9670;&nbsp;</a></span>get_snakemake_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string snakemake_unit_tests::cargs::get_snakemake_log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the snakemake log for the successful pipeline run that needs unit tests </p>
<dl class="section return"><dt>Returns</dt><dd>name of and path to file as a string</dd></dl>
<p>I'll eventually come back here and annotate this with the full list of snakemake run settings that need to be used to make this log sufficiently informative </p>

</div>
</div>
<a id="a022cc6ee8a36c60f09e228c494719d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022cc6ee8a36c60f09e228c494719d64">&#9670;&nbsp;</a></span>help()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::help </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine whether the user has requested help documentation </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user has requested help documentation</dd></dl>
<p>This test is separate from whether the user has run the software with no flags </p>

</div>
</div>
<a id="aa6ed23df6e8352dcd2a2607688bb2180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ed23df6e8352dcd2a2607688bb2180">&#9670;&nbsp;</a></span>initialize_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::cargs::initialize_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set user help documentation and default values for parameters as needed </p>
<p>Note the weird syntax with overloaded () operators. The lists are not separated by commas. </p>

</div>
</div>
<a id="a940197b74bb1793509c339387a4730c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940197b74bb1793509c339387a4730c7">&#9670;&nbsp;</a></span>override_if_specified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::filesystem::path snakemake_unit_tests::cargs::override_if_specified </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cli_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>params_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the first parameter is nonempty, return it; otherwise return the second </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cli_entry</td><td>the value for the parameter given on the command line </td></tr>
    <tr><td class="paramname">params_entry</td><td>the value for the parameter loaded from the yaml config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resolved value from the two provided </dd></dl>

</div>
</div>
<a id="aa50a26e90723123d7318296b1a120b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50a26e90723123d7318296b1a120b65">&#9670;&nbsp;</a></span>print_help()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snakemake_unit_tests::cargs::print_help </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>report help documentation to arbitrary output stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>stream to which to write help documentation</td></tr>
  </table>
  </dd>
</dl>
<p>Parameter should probably be std::cout or std::cerr at your preference. </p>

</div>
</div>
<a id="a7f28c79bacf37a3cf205061251eb41ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f28c79bacf37a3cf205061251eb41ac">&#9670;&nbsp;</a></span>set_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsnakemake__unit__tests_1_1params.html">snakemake_unit_tests::params</a> snakemake_unit_tests::cargs::set_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deal with parameter settings, across CLI and config yaml </p>
<dl class="section return"><dt>Returns</dt><dd>params object containing consistent parameter settings</dd></dl>
<p>note that this should be called after <a class="el" href="classsnakemake__unit__tests_1_1cargs.html#aa6ed23df6e8352dcd2a2607688bb2180" title="set user help documentation and default values for parameters as needed">initialize_options()</a>, and will have fairly lackluster effects otherwise lol </p>

</div>
</div>
<a id="aecc9bee27294c2cc8ac3423954749964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc9bee27294c2cc8ac3423954749964">&#9670;&nbsp;</a></span>update_added_content()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::update_added_content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get user flag for updating added files and directories in place </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user wants to update existing tests' added files and directories </dd></dl>

</div>
</div>
<a id="ac89eba739d1cbc9eac095e7989c00d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89eba739d1cbc9eac095e7989c00d8a">&#9670;&nbsp;</a></span>update_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::update_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get user flag for updating all parts of unit tests </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user wants a full replacement of all unit test content </dd></dl>

</div>
</div>
<a id="a08a00a9c0db47315111e027b5e43dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a00a9c0db47315111e027b5e43dfce">&#9670;&nbsp;</a></span>update_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::update_inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get user flag for updating unit tests' inputs </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user wants to update existing tests' inputs</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>you probably don't want to do this, unless you're updating everything </dd></dl>

</div>
</div>
<a id="a48364153c7fe7da02f0a0736107a8634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48364153c7fe7da02f0a0736107a8634">&#9670;&nbsp;</a></span>update_outputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::update_outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get user flag for updating unit tests' outputs </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user wants to update existing tests' outputs</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>you probably don't want to do this, unless you're updating everything </dd></dl>

</div>
</div>
<a id="ac01a5f0457c93e52bac00ec280d61f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01a5f0457c93e52bac00ec280d61f58">&#9670;&nbsp;</a></span>update_pytest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::update_pytest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get user flag for updating pytest infrastructure </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user wants to update existing tests' pytest content </dd></dl>

</div>
</div>
<a id="a95e6b64164687848fe05bd06b8cd4f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e6b64164687848fe05bd06b8cd4f07">&#9670;&nbsp;</a></span>update_snakefiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::update_snakefiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get user flag for updating existing tests in place (snakefiles only) </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user wants to update existing tests' snakefiles </dd></dl>

</div>
</div>
<a id="a58251551386f449835aa166dfc788a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58251551386f449835aa166dfc788a39">&#9670;&nbsp;</a></span>vector_convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;value_type&gt; snakemake_unit_tests::cargs::vector_convert </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cast entries of a vector into something else </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">target</td><td>type for conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector of strings to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted vector</dd></dl>
<p>there are definitely less silly ways of doing this </p>

</div>
</div>
<a id="a03a59ceee21f04905a7dc5eb6cf9f63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a59ceee21f04905a7dc5eb6cf9f63a">&#9670;&nbsp;</a></span>verbose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool snakemake_unit_tests::cargs::verbose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine whether the user has requested verbose logging output </p>
<dl class="section return"><dt>Returns</dt><dd>whether the user has requested verbose logging output </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>snakemake_unit_tests/<a class="el" href="cargs_8h_source.html">cargs.h</a></li>
<li>snakemake_unit_tests/<a class="el" href="cargs_8cc.html">cargs.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
